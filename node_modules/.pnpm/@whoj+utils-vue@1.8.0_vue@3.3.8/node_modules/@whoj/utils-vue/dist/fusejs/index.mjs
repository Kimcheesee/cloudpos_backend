/**
 * @license MIT
 * @module @whoj/utils-vue@1.8.0
 * @copyright (c) 2023 Jonson B.
 */
import Fuse from 'fuse.js';
import { ref, watch, computed } from 'vue-demi';
class FuseJS {
  /**
   * @type Ref
   */
  fuse;
  /**
   * @type Ref
   */
  resultsRaw;
  /**
   * @type ComputedRef
   */
  results;
  /**
   * @type Ref
   */
  search;
  /**
   * @type ComputedRef
   */
  noResults;
  /**
   * @param items
   * @param options
   */
  /**
   * It takes an array of items and an optional FuseOptions object, and then it creates a new Fuse instance with those
   * items and options, and then it runs the search with the current search value
   * @param items - DataT[] - The items to search through.
   * @param options - FuseOptions<DataT>
   */
  loadItems(items, options) {
    this.fuse = ref(new Fuse(items, options));
    this.runSearch(this.search.value);
  }
  /**
   * If there is no search string, clear the results. Otherwise, search the fuse
   * @param {string} [search] - The search string to use.
   * @returns The results of the search.
   */
  runSearch(search) {
    if (!this.fuse) {
      return;
    }
    if (!search) {
      this.resultsRaw.value = [];
      return;
    }
    this.resultsRaw.value = this.fuse.value.search(search);
  }
  /**
   * We create a new Fuse instance with the list of items and options, and then we create a computed property that returns
   * the results of the search
   * @param list - This is the list of items that you want to search. It can be an array of items, or a reactive object
   * that contains an array of items.
   * @param options - FuseOptions<DataT>
   */
  constructor(list, options) {
    this.search = ref("");
    let locArr = [];
    if (Array.isArray(list)) {
      locArr = list;
    } else if (list) {
      locArr = list.value ?? [];
      watch(list, () => {
        this.loadItems(list.value ?? []);
      });
    }
    this.fuse = ref(new Fuse(locArr, options));
    this.resultsRaw = ref([]);
    this.noResults = computed(() => {
      return this.results.value.length === 0 && this.search.value.length > 0;
    });
    this.results = computed(() => this.resultsRaw.value.map((r) => r.item));
    watch(this.search, this.runSearch);
  }
}
function useFuseJs(list, options) {
  return new FuseJS(list, options);
}
export { FuseJS, useFuseJs };
//# sourceMappingURL=index.mjs.map
