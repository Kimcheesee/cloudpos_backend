/**
 * @license MIT
 * @module @whoj/utils-vue@1.8.0
 * @copyright (c) 2023 Jonson B.
 */
import { ref, watch } from 'vue-demi';
import { getDocument, noop, objectEntries } from '@whoj/utils-core';
import { unrefOf } from './unrefOf.mjs';
import { listenEvent } from './listenEvent.mjs';
import { tryOnMounted } from './tryOnMounted.mjs';
import { tryOnUnmounted } from './tryOnUnmounted.mjs';
let _id = 0;
function useLinkTag(href, onLoaded = noop, options = {}) {
  const {
    as,
    media,
    crossOrigin,
    referrerPolicy,
    blocking,
    immediate = true,
    manual = false,
    attrs = {},
    type = "text/css",
    rel = "stylesheet",
    id = `use_link_tag_${++_id}`,
    document = getDocument()
  } = options;
  const linkTag = ref();
  const loaded = ref();
  let _promise = null;
  const _evtListeners = {};
  const findLinkEl = () => document.querySelector(`link[id="${id}"]`);
  const loadLink = (waitForLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      linkTag.value = el2;
      resolve(el2);
      return el2;
    };
    if (!document) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = findLinkEl();
    if (!el) {
      el = document.createElement("link");
      el.id = id;
      el.rel = rel;
      el.type = type;
      el.href = unrefOf(href);
      if (as) {
        el.as = as;
      }
      if (media) {
        el.media = media;
      }
      if (crossOrigin) {
        el.crossOrigin = crossOrigin;
      }
      if (referrerPolicy) {
        el.referrerPolicy = referrerPolicy;
      }
      if (blocking) {
        attrs.blocking = blocking;
      }
      objectEntries(attrs).forEach(([name, value]) => el?.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    _evtListeners.error = listenEvent(el, "error", (event) => reject(event));
    _evtListeners.abort = listenEvent(el, "abort", (event) => reject(event));
    _evtListeners.load = listenEvent(el, "load", () => {
      el.setAttribute("data-loaded", "true");
      loaded.value = true;
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend) {
      el = document.head.appendChild(el);
    }
    if (!waitForLoad) {
      resolveWithElement(el);
    }
  });
  const load = (waitForLoad = true) => {
    if (!_promise) {
      _promise = loadLink(waitForLoad);
    }
    return _promise;
  };
  const unload = () => {
    if (!document) {
      return;
    }
    _promise = null;
    if (linkTag.value) {
      linkTag.value = void 0;
    }
    const el = findLinkEl();
    if (el) {
      objectEntries(_evtListeners).forEach(([name, unregister]) => {
        unregister();
      });
      document.head.removeChild(el);
    }
    loaded.value = void 0;
  };
  const update = () => {
    const el = findLinkEl();
    if (el) {
      el.href = unrefOf(href);
    }
  };
  if (immediate && !manual) {
    tryOnMounted(load);
  }
  if (!manual) {
    tryOnUnmounted(unload);
  }
  watch(
    () => unrefOf(href),
    update,
    { immediate: true, flush: "post" }
  );
  return { linkTag, loaded, load, unload };
}
export { useLinkTag };
//# sourceMappingURL=useLinkTag.mjs.map
