/**
 * @license MIT
 * @module @whoj/utils-vue@1.8.0
 * @copyright (c) 2023 Jonson B.
 */

import * as vue_demi from 'vue-demi';
import Resumable from 'resumablejs';
import { ComputedRefableElement } from './unrefOfEl.js';

type ResumableFile = Resumable['files'][number];
type ConfigurationHash = ConstructorParameters<typeof Resumable>;
interface UploaderTargetFunction {
    (uploader: Resumable): Resumable;
}
interface UploaderTargetObject {
    browse: ComputedRefableElement;
    drop?: ComputedRefableElement;
}
interface UseResumableUploaderOptions extends ConfigurationHash {
}
declare function useResumableUploader(options: UseResumableUploaderOptions, target: UploaderTargetObject | UploaderTargetFunction): {
    files: vue_demi.Ref<{
        file: {
            resumableObj: {
                support: boolean;
                opts: {
                    target?: string;
                    chunkSize?: number;
                    forceChunkSize?: boolean;
                    simultaneousUploads?: number;
                    fileParameterName?: string;
                    chunkNumberParameterName?: string;
                    totalChunksParameterName?: string;
                    chunkSizeParameterName?: string;
                    totalSizeParameterName?: string;
                    identifierParameterName?: string;
                    fileNameParameterName?: string;
                    relativePathParameterName?: string;
                    currentChunkSizeParameterName?: string;
                    typeParameterName?: string;
                    query?: Object;
                    testMethod?: "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE";
                    uploadMethod?: "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE";
                    parameterNamespace?: string;
                    headers?: Object | ((file: any) => Object);
                    method?: "multipart" | "octet";
                    prioritizeFirstAndLastChunk?: boolean;
                    testChunks?: boolean;
                    preprocess?: (chunk: Resumable.ResumableChunk) => Resumable.ResumableChunk;
                    generateUniqueIdentifier?: () => string;
                    maxFiles?: number;
                    maxFilesErrorCallback?: (files: any, errorCount: any) => void;
                    minFileSize?: boolean;
                    minFileSizeErrorCallback?: (file: any, errorCount: any) => void;
                    maxFileSize?: boolean;
                    maxFileSizeErrorCallback?: (file: any, errorCount: any) => void;
                    fileType?: string[];
                    fileTypeErrorCallback?: (file: any, errorCount: any) => void;
                    maxChunkRetries?: number;
                    chunkRetryInterval?: number;
                    withCredentials?: boolean;
                    setChunkTypeFromFile?: boolean;
                };
                files: any[];
                events: any[];
                version: number;
                assignBrowse: {
                    (domNode: Element, isDirectory: boolean): void;
                    (domNodes: Element[], isDirectory: boolean): void;
                };
                assignDrop: {
                    (domNode: Element): void;
                    (domNodes: Element[]): void;
                };
                unAssignDrop: {
                    (domNode: Element): void;
                    (domNodes: Element[]): void;
                };
                upload: () => void;
                uploadNextChunk: () => void;
                pause: () => void;
                cancel: () => void;
                fire: () => void;
                progress: () => number;
                isUploading: () => boolean;
                addFile: (file: File) => void;
                addFiles: (files: File[]) => void;
                removeFile: (file: Resumable.ResumableFile) => void;
                getFromUniqueIdentifier: (uniqueIdentifier: string) => void;
                getSize: () => void;
                getOpt: (o: string) => any;
                on: {
                    (event: string, callback: Function): void;
                    (event: "fileSuccess", callback: (file: Resumable.ResumableFile) => void): any;
                    (event: "fileProgress", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "fileAdded", callback: (file: Resumable.ResumableFile, event: DragEvent) => void): void;
                    (event: "filesAdded", callback: (files: Resumable.ResumableFile[]) => void): void;
                    (event: "fileRetry", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "fileError", callback: (file: Resumable.ResumableFile, message: string) => void): void;
                    (event: "uploadStart", callback: () => void): void;
                    (event: "complete", callback: () => void): void;
                    (event: "progress", callback: () => void): void;
                    (event: "error", callback: (message: string, file: Resumable.ResumableFile) => void): void;
                    (event: "pause", callback: () => void): void;
                    (event: "beforeCancel", callback: () => void): void;
                    (event: "cancel", callback: () => void): void;
                    (event: "chunkingStart", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "chunkingProgress", callback: (file: Resumable.ResumableFile, ratio: any) => void): void;
                    (event: "chunkingComplete", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "catchAll", callback: () => void): any;
                };
                void: any;
            };
            file: File;
            fileName: string;
            relativePath: string;
            size: number;
            uniqueIdentifier: string;
            chunks: Resumable.ResumableChunk[];
            progress: (relative: boolean) => number;
            abort: () => void;
            cancel: () => void;
            retry: () => void;
            bootstrap: () => void;
            isUploading: () => boolean;
            isComplete: () => boolean;
        };
        progress: number;
        status: "error" | "uploading" | "success" | "canceled" | "retrying";
    }[]>;
    uploader: vue_demi.Ref<Resumable>;
    findFile: (file: ResumableFile) => {
        file: {
            resumableObj: {
                support: boolean;
                opts: {
                    target?: string;
                    chunkSize?: number;
                    forceChunkSize?: boolean;
                    simultaneousUploads?: number;
                    fileParameterName?: string;
                    chunkNumberParameterName?: string;
                    totalChunksParameterName?: string;
                    chunkSizeParameterName?: string;
                    totalSizeParameterName?: string;
                    identifierParameterName?: string;
                    fileNameParameterName?: string;
                    relativePathParameterName?: string;
                    currentChunkSizeParameterName?: string;
                    typeParameterName?: string;
                    query?: Object;
                    testMethod?: "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE";
                    uploadMethod?: "GET" | "POST" | "OPTIONS" | "PUT" | "DELETE";
                    parameterNamespace?: string;
                    headers?: Object | ((file: any) => Object);
                    method?: "multipart" | "octet";
                    prioritizeFirstAndLastChunk?: boolean;
                    testChunks?: boolean;
                    preprocess?: (chunk: Resumable.ResumableChunk) => Resumable.ResumableChunk;
                    generateUniqueIdentifier?: () => string;
                    maxFiles?: number;
                    maxFilesErrorCallback?: (files: any, errorCount: any) => void;
                    minFileSize?: boolean;
                    minFileSizeErrorCallback?: (file: any, errorCount: any) => void;
                    maxFileSize?: boolean;
                    maxFileSizeErrorCallback?: (file: any, errorCount: any) => void;
                    fileType?: string[];
                    fileTypeErrorCallback?: (file: any, errorCount: any) => void;
                    maxChunkRetries?: number;
                    chunkRetryInterval?: number;
                    withCredentials?: boolean;
                    setChunkTypeFromFile?: boolean;
                };
                files: any[];
                events: any[];
                version: number;
                assignBrowse: {
                    (domNode: Element, isDirectory: boolean): void;
                    (domNodes: Element[], isDirectory: boolean): void;
                };
                assignDrop: {
                    (domNode: Element): void;
                    (domNodes: Element[]): void;
                };
                unAssignDrop: {
                    (domNode: Element): void;
                    (domNodes: Element[]): void;
                };
                upload: () => void;
                uploadNextChunk: () => void;
                pause: () => void;
                cancel: () => void;
                fire: () => void;
                progress: () => number;
                isUploading: () => boolean;
                addFile: (file: File) => void;
                addFiles: (files: File[]) => void;
                removeFile: (file: Resumable.ResumableFile) => void;
                getFromUniqueIdentifier: (uniqueIdentifier: string) => void;
                getSize: () => void;
                getOpt: (o: string) => any;
                on: {
                    (event: string, callback: Function): void;
                    (event: "fileSuccess", callback: (file: Resumable.ResumableFile) => void): any;
                    (event: "fileProgress", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "fileAdded", callback: (file: Resumable.ResumableFile, event: DragEvent) => void): void;
                    (event: "filesAdded", callback: (files: Resumable.ResumableFile[]) => void): void;
                    (event: "fileRetry", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "fileError", callback: (file: Resumable.ResumableFile, message: string) => void): void;
                    (event: "uploadStart", callback: () => void): void;
                    (event: "complete", callback: () => void): void;
                    (event: "progress", callback: () => void): void;
                    (event: "error", callback: (message: string, file: Resumable.ResumableFile) => void): void;
                    (event: "pause", callback: () => void): void;
                    (event: "beforeCancel", callback: () => void): void;
                    (event: "cancel", callback: () => void): void;
                    (event: "chunkingStart", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "chunkingProgress", callback: (file: Resumable.ResumableFile, ratio: any) => void): void;
                    (event: "chunkingComplete", callback: (file: Resumable.ResumableFile) => void): void;
                    (event: "catchAll", callback: () => void): any;
                };
                void: any;
            };
            file: File;
            fileName: string;
            relativePath: string;
            size: number;
            uniqueIdentifier: string;
            chunks: Resumable.ResumableChunk[];
            progress: (relative: boolean) => number;
            abort: () => void;
            cancel: () => void;
            retry: () => void;
            bootstrap: () => void;
            isUploading: () => boolean;
            isComplete: () => boolean;
        };
        progress: number;
        status: "error" | "uploading" | "success" | "canceled" | "retrying";
    };
    cancelFile: (file: ResumableFile) => void;
};

export { type UseResumableUploaderOptions, useResumableUploader };
//# sourceMappingURL=useResumableUploader.d.ts.map
