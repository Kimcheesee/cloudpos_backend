/**
 * @license MIT
 * @module @whoj/utils-vue@1.8.0
 * @copyright (c) 2023 Jonson B.
 */

this.Whoj = this.Whoj || {};
this.Whoj.Utils = this.Whoj.Utils || {};
this.Whoj.Utils.Vue = (function (exports, vueDemi) {
  'use strict';

  /**
   * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)
   *
   * Copyright (c) 2022 Kiro Risk (http://kiro.me)
   * All Rights Reserved. Apache Software License 2.0
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   */

  function isArray(value) {
    return !Array.isArray
      ? getTag(value) === '[object Array]'
      : Array.isArray(value)
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
  const INFINITY = 1 / 0;
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value
    }
    let result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result
  }

  function toString$1(value) {
    return value == null ? '' : baseToString(value)
  }

  function isString$1(value) {
    return typeof value === 'string'
  }

  function isNumber$1(value) {
    return typeof value === 'number'
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
  function isBoolean(value) {
    return (
      value === true ||
      value === false ||
      (isObjectLike(value) && getTag(value) == '[object Boolean]')
    )
  }

  function isObject$1(value) {
    return typeof value === 'object'
  }

  // Checks if `value` is object-like.
  function isObjectLike(value) {
    return isObject$1(value) && value !== null
  }

  function isDefined(value) {
    return value !== undefined && value !== null
  }

  function isBlank(value) {
    return !value.trim().length
  }

  // Gets the `toStringTag` of `value`.
  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
  function getTag(value) {
    return value == null
      ? value === undefined
        ? '[object Undefined]'
        : '[object Null]'
      : Object.prototype.toString.call(value)
  }

  const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';

  const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

  const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
    `Invalid value for key ${key}`;

  const PATTERN_LENGTH_TOO_LARGE = (max) =>
    `Pattern length exceeds max of ${max}.`;

  const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

  const INVALID_KEY_WEIGHT_VALUE = (key) =>
    `Property 'weight' in key '${key}' must be a positive integer`;

  const hasOwn = Object.prototype.hasOwnProperty;

  class KeyStore {
    constructor(keys) {
      this._keys = [];
      this._keyMap = {};

      let totalWeight = 0;

      keys.forEach((key) => {
        let obj = createKey(key);

        totalWeight += obj.weight;

        this._keys.push(obj);
        this._keyMap[obj.id] = obj;

        totalWeight += obj.weight;
      });

      // Normalize weights so that their sum is equal to 1
      this._keys.forEach((key) => {
        key.weight /= totalWeight;
      });
    }
    get(keyId) {
      return this._keyMap[keyId]
    }
    keys() {
      return this._keys
    }
    toJSON() {
      return JSON.stringify(this._keys)
    }
  }

  function createKey(key) {
    let path = null;
    let id = null;
    let src = null;
    let weight = 1;
    let getFn = null;

    if (isString$1(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, 'name')) {
        throw new Error(MISSING_KEY_PROPERTY('name'))
      }

      const name = key.name;
      src = name;

      if (hasOwn.call(key, 'weight')) {
        weight = key.weight;

        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
        }
      }

      path = createKeyPath(name);
      id = createKeyId(name);
      getFn = key.getFn;
    }

    return { path, id, weight, src, getFn }
  }

  function createKeyPath(key) {
    return isArray(key) ? key : key.split('.')
  }

  function createKeyId(key) {
    return isArray(key) ? key.join('.') : key
  }

  function get(obj, path) {
    let list = [];
    let arr = false;

    const deepGet = (obj, path, index) => {
      if (!isDefined(obj)) {
        return
      }
      if (!path[index]) {
        // If there's no path left, we've arrived at the object we care about.
        list.push(obj);
      } else {
        let key = path[index];

        const value = obj[key];

        if (!isDefined(value)) {
          return
        }

        // If we're at the last value in the path, and if it's a string/number/bool,
        // add it to the list
        if (
          index === path.length - 1 &&
          (isString$1(value) || isNumber$1(value) || isBoolean(value))
        ) {
          list.push(toString$1(value));
        } else if (isArray(value)) {
          arr = true;
          // Search each item in the array.
          for (let i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path, index + 1);
          }
        } else if (path.length) {
          // An object. Recurse further.
          deepGet(value, path, index + 1);
        }
      }
    };

    // Backwards compatibility (since path used to be a string)
    deepGet(obj, isString$1(path) ? path.split('.') : path, 0);

    return arr ? list : list[0]
  }

  const MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };

  const BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: (a, b) =>
      a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
  };

  const FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };

  const AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false,
    // The weight to determine how much field length norm effects scoring.
    fieldNormWeight: 1
  };

  var Config = {
    ...BasicOptions,
    ...MatchOptions,
    ...FuzzyOptions,
    ...AdvancedOptions
  };

  const SPACE = /[^ ]+/g;

  // Field-length norm: the shorter the field, the higher the weight.
  // Set to 3 decimals to reduce index size.
  function norm(weight = 1, mantissa = 3) {
    const cache = new Map();
    const m = Math.pow(10, mantissa);

    return {
      get(value) {
        const numTokens = value.match(SPACE).length;

        if (cache.has(numTokens)) {
          return cache.get(numTokens)
        }

        // Default function is 1/sqrt(x), weight makes that variable
        const norm = 1 / Math.pow(numTokens, 0.5 * weight);

        // In place of `toFixed(mantissa)`, for faster computation
        const n = parseFloat(Math.round(norm * m) / m);

        cache.set(numTokens, n);

        return n
      },
      clear() {
        cache.clear();
      }
    }
  }

  class FuseIndex {
    constructor({
      getFn = Config.getFn,
      fieldNormWeight = Config.fieldNormWeight
    } = {}) {
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;

      this.setIndexRecords();
    }
    setSources(docs = []) {
      this.docs = docs;
    }
    setIndexRecords(records = []) {
      this.records = records;
    }
    setKeys(keys = []) {
      this.keys = keys;
      this._keysMap = {};
      keys.forEach((key, idx) => {
        this._keysMap[key.id] = idx;
      });
    }
    create() {
      if (this.isCreated || !this.docs.length) {
        return
      }

      this.isCreated = true;

      // List is Array<String>
      if (isString$1(this.docs[0])) {
        this.docs.forEach((doc, docIndex) => {
          this._addString(doc, docIndex);
        });
      } else {
        // List is Array<Object>
        this.docs.forEach((doc, docIndex) => {
          this._addObject(doc, docIndex);
        });
      }

      this.norm.clear();
    }
    // Adds a doc to the end of the index
    add(doc) {
      const idx = this.size();

      if (isString$1(doc)) {
        this._addString(doc, idx);
      } else {
        this._addObject(doc, idx);
      }
    }
    // Removes the doc at the specified index of the index
    removeAt(idx) {
      this.records.splice(idx, 1);

      // Change ref index of every subsquent doc
      for (let i = idx, len = this.size(); i < len; i += 1) {
        this.records[i].i -= 1;
      }
    }
    getValueForItemAtKeyId(item, keyId) {
      return item[this._keysMap[keyId]]
    }
    size() {
      return this.records.length
    }
    _addString(doc, docIndex) {
      if (!isDefined(doc) || isBlank(doc)) {
        return
      }

      let record = {
        v: doc,
        i: docIndex,
        n: this.norm.get(doc)
      };

      this.records.push(record);
    }
    _addObject(doc, docIndex) {
      let record = { i: docIndex, $: {} };

      // Iterate over every key (i.e, path), and fetch the value at that key
      this.keys.forEach((key, keyIndex) => {
        let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);

        if (!isDefined(value)) {
          return
        }

        if (isArray(value)) {
          let subRecords = [];
          const stack = [{ nestedArrIndex: -1, value }];

          while (stack.length) {
            const { nestedArrIndex, value } = stack.pop();

            if (!isDefined(value)) {
              continue
            }

            if (isString$1(value) && !isBlank(value)) {
              let subRecord = {
                v: value,
                i: nestedArrIndex,
                n: this.norm.get(value)
              };

              subRecords.push(subRecord);
            } else if (isArray(value)) {
              value.forEach((item, k) => {
                stack.push({
                  nestedArrIndex: k,
                  value: item
                });
              });
            } else ;
          }
          record.$[keyIndex] = subRecords;
        } else if (isString$1(value) && !isBlank(value)) {
          let subRecord = {
            v: value,
            n: this.norm.get(value)
          };

          record.$[keyIndex] = subRecord;
        }
      });

      this.records.push(record);
    }
    toJSON() {
      return {
        keys: this.keys,
        records: this.records
      }
    }
  }

  function createIndex(
    keys,
    docs,
    { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
  ) {
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex
  }

  function parseIndex(
    data,
    { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
  ) {
    const { keys, records } = data;
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex
  }

  function computeScore$1(
    pattern,
    {
      errors = 0,
      currentLocation = 0,
      expectedLocation = 0,
      distance = Config.distance,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    const accuracy = errors / pattern.length;

    if (ignoreLocation) {
      return accuracy
    }

    const proximity = Math.abs(expectedLocation - currentLocation);

    if (!distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy
    }

    return accuracy + proximity / distance
  }

  function convertMaskToIndices(
    matchmask = [],
    minMatchCharLength = Config.minMatchCharLength
  ) {
    let indices = [];
    let start = -1;
    let end = -1;
    let i = 0;

    for (let len = matchmask.length; i < len; i += 1) {
      let match = matchmask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }

    // (i-1 - start) + 1 => i - start
    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }

    return indices
  }

  // Machine word size
  const MAX_BITS = 32;

  function search(
    text,
    pattern,
    patternAlphabet,
    {
      location = Config.location,
      distance = Config.distance,
      threshold = Config.threshold,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      includeMatches = Config.includeMatches,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
    }

    const patternLen = pattern.length;
    // Set starting location at beginning text and initialize the alphabet.
    const textLen = text.length;
    // Handle the case when location > text.length
    const expectedLocation = Math.max(0, Math.min(location, textLen));
    // Highest score beyond which we give up.
    let currentThreshold = threshold;
    // Is there a nearby exact match? (speedup)
    let bestLocation = expectedLocation;

    // Performance: only computer matches when the minMatchCharLength > 1
    // OR if `includeMatches` is true.
    const computeMatches = minMatchCharLength > 1 || includeMatches;
    // A mask of the matches, used for building the indices
    const matchMask = computeMatches ? Array(textLen) : [];

    let index;

    // Get all exact matches, here for speed up
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      let score = computeScore$1(pattern, {
        currentLocation: index,
        expectedLocation,
        distance,
        ignoreLocation
      });

      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;

      if (computeMatches) {
        let i = 0;
        while (i < patternLen) {
          matchMask[index + i] = 1;
          i += 1;
        }
      }
    }

    // Reset the best location
    bestLocation = -1;

    let lastBitArr = [];
    let finalScore = 1;
    let binMax = patternLen + textLen;

    const mask = 1 << (patternLen - 1);

    for (let i = 0; i < patternLen; i += 1) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      let binMin = 0;
      let binMid = binMax;

      while (binMin < binMid) {
        const score = computeScore$1(pattern, {
          errors: i,
          currentLocation: expectedLocation + binMid,
          expectedLocation,
          distance,
          ignoreLocation
        });

        if (score <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }

        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }

      // Use the result from this iteration as the maximum for the next.
      binMax = binMid;

      let start = Math.max(1, expectedLocation - binMid + 1);
      let finish = findAllMatches
        ? textLen
        : Math.min(expectedLocation + binMid, textLen) + patternLen;

      // Initialize the bit array
      let bitArr = Array(finish + 2);

      bitArr[finish + 1] = (1 << i) - 1;

      for (let j = finish; j >= start; j -= 1) {
        let currentLocation = j - 1;
        let charMatch = patternAlphabet[text.charAt(currentLocation)];

        if (computeMatches) {
          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
          matchMask[currentLocation] = +!!charMatch;
        }

        // First pass: exact match
        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

        // Subsequent passes: fuzzy match
        if (i) {
          bitArr[j] |=
            ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
        }

        if (bitArr[j] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: i,
            currentLocation,
            expectedLocation,
            distance,
            ignoreLocation
          });

          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (finalScore <= currentThreshold) {
            // Indeed it is
            currentThreshold = finalScore;
            bestLocation = currentLocation;

            // Already passed `loc`, downhill from here on in.
            if (bestLocation <= expectedLocation) {
              break
            }

            // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }

      // No hope for a (better) match at greater error levels.
      const score = computeScore$1(pattern, {
        errors: i + 1,
        currentLocation: expectedLocation,
        expectedLocation,
        distance,
        ignoreLocation
      });

      if (score > currentThreshold) {
        break
      }

      lastBitArr = bitArr;
    }

    const result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(0.001, finalScore)
    };

    if (computeMatches) {
      const indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }

    return result
  }

  function createPatternAlphabet(pattern) {
    let mask = {};

    for (let i = 0, len = pattern.length; i < len; i += 1) {
      const char = pattern.charAt(i);
      mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
    }

    return mask
  }

  class BitapSearch {
    constructor(
      pattern,
      {
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance,
        includeMatches = Config.includeMatches,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        isCaseSensitive = Config.isCaseSensitive,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      this.options = {
        location,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreLocation
      };

      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();

      this.chunks = [];

      if (!this.pattern.length) {
        return
      }

      const addChunk = (pattern, startIndex) => {
        this.chunks.push({
          pattern,
          alphabet: createPatternAlphabet(pattern),
          startIndex
        });
      };

      const len = this.pattern.length;

      if (len > MAX_BITS) {
        let i = 0;
        const remainder = len % MAX_BITS;
        const end = len - remainder;

        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }

        if (remainder) {
          const startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }

    searchIn(text) {
      const { isCaseSensitive, includeMatches } = this.options;

      if (!isCaseSensitive) {
        text = text.toLowerCase();
      }

      // Exact match
      if (this.pattern === text) {
        let result = {
          isMatch: true,
          score: 0
        };

        if (includeMatches) {
          result.indices = [[0, text.length - 1]];
        }

        return result
      }

      // Otherwise, use Bitap algorithm
      const {
        location,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        ignoreLocation
      } = this.options;

      let allIndices = [];
      let totalScore = 0;
      let hasMatches = false;

      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
        const { isMatch, score, indices } = search(text, pattern, alphabet, {
          location: location + startIndex,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          includeMatches,
          ignoreLocation
        });

        if (isMatch) {
          hasMatches = true;
        }

        totalScore += score;

        if (isMatch && indices) {
          allIndices = [...allIndices, ...indices];
        }
      });

      let result = {
        isMatch: hasMatches,
        score: hasMatches ? totalScore / this.chunks.length : 1
      };

      if (hasMatches && includeMatches) {
        result.indices = allIndices;
      }

      return result
    }
  }

  class BaseMatch {
    constructor(pattern) {
      this.pattern = pattern;
    }
    static isMultiMatch(pattern) {
      return getMatch(pattern, this.multiRegex)
    }
    static isSingleMatch(pattern) {
      return getMatch(pattern, this.singleRegex)
    }
    search(/*text*/) {}
  }

  function getMatch(pattern, exp) {
    const matches = pattern.match(exp);
    return matches ? matches[1] : null
  }

  // Token: 'file

  class ExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'exact'
    }
    static get multiRegex() {
      return /^="(.*)"$/
    }
    static get singleRegex() {
      return /^=(.*)$/
    }
    search(text) {
      const isMatch = text === this.pattern;

      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      }
    }
  }

  // Token: !fire

  class InverseExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'inverse-exact'
    }
    static get multiRegex() {
      return /^!"(.*)"$/
    }
    static get singleRegex() {
      return /^!(.*)$/
    }
    search(text) {
      const index = text.indexOf(this.pattern);
      const isMatch = index === -1;

      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      }
    }
  }

  // Token: ^file

  class PrefixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'prefix-exact'
    }
    static get multiRegex() {
      return /^\^"(.*)"$/
    }
    static get singleRegex() {
      return /^\^(.*)$/
    }
    search(text) {
      const isMatch = text.startsWith(this.pattern);

      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      }
    }
  }

  // Token: !^fire

  class InversePrefixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'inverse-prefix-exact'
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/
    }
    static get singleRegex() {
      return /^!\^(.*)$/
    }
    search(text) {
      const isMatch = !text.startsWith(this.pattern);

      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      }
    }
  }

  // Token: .file$

  class SuffixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'suffix-exact'
    }
    static get multiRegex() {
      return /^"(.*)"\$$/
    }
    static get singleRegex() {
      return /^(.*)\$$/
    }
    search(text) {
      const isMatch = text.endsWith(this.pattern);

      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [text.length - this.pattern.length, text.length - 1]
      }
    }
  }

  // Token: !.file$

  class InverseSuffixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'inverse-suffix-exact'
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/
    }
    static get singleRegex() {
      return /^!(.*)\$$/
    }
    search(text) {
      const isMatch = !text.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      }
    }
  }

  class FuzzyMatch extends BaseMatch {
    constructor(
      pattern,
      {
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance,
        includeMatches = Config.includeMatches,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        isCaseSensitive = Config.isCaseSensitive,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      super(pattern);
      this._bitapSearch = new BitapSearch(pattern, {
        location,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreLocation
      });
    }
    static get type() {
      return 'fuzzy'
    }
    static get multiRegex() {
      return /^"(.*)"$/
    }
    static get singleRegex() {
      return /^(.*)$/
    }
    search(text) {
      return this._bitapSearch.searchIn(text)
    }
  }

  // Token: 'file

  class IncludeMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'include'
    }
    static get multiRegex() {
      return /^'"(.*)"$/
    }
    static get singleRegex() {
      return /^'(.*)$/
    }
    search(text) {
      let location = 0;
      let index;

      const indices = [];
      const patternLen = this.pattern.length;

      // Get all exact matches
      while ((index = text.indexOf(this.pattern, location)) > -1) {
        location = index + patternLen;
        indices.push([index, location - 1]);
      }

      const isMatch = !!indices.length;

      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices
      }
    }
  }

  // â—Order is important. DO NOT CHANGE.
  const searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch
  ];

  const searchersLen = searchers.length;

  // Regex to split by spaces, but keep anything in quotes together
  const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  const OR_TOKEN = '|';

  // Return a 2D array representation of the query, for simpler parsing.
  // Example:
  // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
  function parseQuery(pattern, options = {}) {
    return pattern.split(OR_TOKEN).map((item) => {
      let query = item
        .trim()
        .split(SPACE_RE)
        .filter((item) => item && !!item.trim());

      let results = [];
      for (let i = 0, len = query.length; i < len; i += 1) {
        const queryItem = query[i];

        // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
        let found = false;
        let idx = -1;
        while (!found && ++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }

        if (found) {
          continue
        }

        // 2. Handle single query matches (i.e, once that are *not* quoted)
        idx = -1;
        while (++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isSingleMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            break
          }
        }
      }

      return results
    })
  }

  // These extended matchers can return an array of matches, as opposed
  // to a singl match
  const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

  /**
   * Command-like searching
   * ======================
   *
   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
   * search in a given text.
   *
   * Search syntax:
   *
   * | Token       | Match type                 | Description                            |
   * | ----------- | -------------------------- | -------------------------------------- |
   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
   * | `=scheme`   | exact-match                | Items that are `scheme`                |
   * | `'python`   | include-match              | Items that include `python`            |
   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
   * | `^java`     | prefix-exact-match         | Items that start with `java`           |
   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
   *
   * A single pipe character acts as an OR operator. For example, the following
   * query matches entries that start with `core` and end with either`go`, `rb`,
   * or`py`.
   *
   * ```
   * ^core go$ | rb$ | py$
   * ```
   */
  class ExtendedSearch {
    constructor(
      pattern,
      {
        isCaseSensitive = Config.isCaseSensitive,
        includeMatches = Config.includeMatches,
        minMatchCharLength = Config.minMatchCharLength,
        ignoreLocation = Config.ignoreLocation,
        findAllMatches = Config.findAllMatches,
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance
      } = {}
    ) {
      this.query = null;
      this.options = {
        isCaseSensitive,
        includeMatches,
        minMatchCharLength,
        findAllMatches,
        ignoreLocation,
        location,
        threshold,
        distance
      };

      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.query = parseQuery(this.pattern, this.options);
    }

    static condition(_, options) {
      return options.useExtendedSearch
    }

    searchIn(text) {
      const query = this.query;

      if (!query) {
        return {
          isMatch: false,
          score: 1
        }
      }

      const { includeMatches, isCaseSensitive } = this.options;

      text = isCaseSensitive ? text : text.toLowerCase();

      let numMatches = 0;
      let allIndices = [];
      let totalScore = 0;

      // ORs
      for (let i = 0, qLen = query.length; i < qLen; i += 1) {
        const searchers = query[i];

        // Reset indices
        allIndices.length = 0;
        numMatches = 0;

        // ANDs
        for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
          const searcher = searchers[j];
          const { isMatch, indices, score } = searcher.search(text);

          if (isMatch) {
            numMatches += 1;
            totalScore += score;
            if (includeMatches) {
              const type = searcher.constructor.type;
              if (MultiMatchSet.has(type)) {
                allIndices = [...allIndices, ...indices];
              } else {
                allIndices.push(indices);
              }
            }
          } else {
            totalScore = 0;
            numMatches = 0;
            allIndices.length = 0;
            break
          }
        }

        // OR condition, so if TRUE, return
        if (numMatches) {
          let result = {
            isMatch: true,
            score: totalScore / numMatches
          };

          if (includeMatches) {
            result.indices = allIndices;
          }

          return result
        }
      }

      // Nothing was matched
      return {
        isMatch: false,
        score: 1
      }
    }
  }

  const registeredSearchers = [];

  function register(...args) {
    registeredSearchers.push(...args);
  }

  function createSearcher(pattern, options) {
    for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
      let searcherClass = registeredSearchers[i];
      if (searcherClass.condition(pattern, options)) {
        return new searcherClass(pattern, options)
      }
    }

    return new BitapSearch(pattern, options)
  }

  const LogicalOperator = {
    AND: '$and',
    OR: '$or'
  };

  const KeyType = {
    PATH: '$path',
    PATTERN: '$val'
  };

  const isExpression = (query) =>
    !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

  const isPath = (query) => !!query[KeyType.PATH];

  const isLeaf = (query) =>
    !isArray(query) && isObject$1(query) && !isExpression(query);

  const convertToExplicit = (query) => ({
    [LogicalOperator.AND]: Object.keys(query).map((key) => ({
      [key]: query[key]
    }))
  });

  // When `auto` is `true`, the parse function will infer and initialize and add
  // the appropriate `Searcher` instance
  function parse(query, options, { auto = true } = {}) {
    const next = (query) => {
      let keys = Object.keys(query);

      const isQueryPath = isPath(query);

      if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
        return next(convertToExplicit(query))
      }

      if (isLeaf(query)) {
        const key = isQueryPath ? query[KeyType.PATH] : keys[0];

        const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

        if (!isString$1(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
        }

        const obj = {
          keyId: createKeyId(key),
          pattern
        };

        if (auto) {
          obj.searcher = createSearcher(pattern, options);
        }

        return obj
      }

      let node = {
        children: [],
        operator: keys[0]
      };

      keys.forEach((key) => {
        const value = query[key];

        if (isArray(value)) {
          value.forEach((item) => {
            node.children.push(next(item));
          });
        }
      });

      return node
    };

    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }

    return next(query)
  }

  // Practical scoring function
  function computeScore(
    results,
    { ignoreFieldNorm = Config.ignoreFieldNorm }
  ) {
    results.forEach((result) => {
      let totalScore = 1;

      result.matches.forEach(({ key, norm, score }) => {
        const weight = key ? key.weight : null;

        totalScore *= Math.pow(
          score === 0 && weight ? Number.EPSILON : score,
          (weight || 1) * (ignoreFieldNorm ? 1 : norm)
        );
      });

      result.score = totalScore;
    });
  }

  function transformMatches(result, data) {
    const matches = result.matches;
    data.matches = [];

    if (!isDefined(matches)) {
      return
    }

    matches.forEach((match) => {
      if (!isDefined(match.indices) || !match.indices.length) {
        return
      }

      const { indices, value } = match;

      let obj = {
        indices,
        value
      };

      if (match.key) {
        obj.key = match.key.src;
      }

      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }

      data.matches.push(obj);
    });
  }

  function transformScore(result, data) {
    data.score = result.score;
  }

  function format(
    results,
    docs,
    {
      includeMatches = Config.includeMatches,
      includeScore = Config.includeScore
    } = {}
  ) {
    const transformers = [];

    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);

    return results.map((result) => {
      const { idx } = result;

      const data = {
        item: docs[idx],
        refIndex: idx
      };

      if (transformers.length) {
        transformers.forEach((transformer) => {
          transformer(result, data);
        });
      }

      return data
    })
  }

  class Fuse {
    constructor(docs, options = {}, index) {
      this.options = { ...Config, ...options };

      if (
        this.options.useExtendedSearch &&
        !true
      ) {
        throw new Error(EXTENDED_SEARCH_UNAVAILABLE)
      }

      this._keyStore = new KeyStore(this.options.keys);

      this.setCollection(docs, index);
    }

    setCollection(docs, index) {
      this._docs = docs;

      if (index && !(index instanceof FuseIndex)) {
        throw new Error(INCORRECT_INDEX_TYPE)
      }

      this._myIndex =
        index ||
        createIndex(this.options.keys, this._docs, {
          getFn: this.options.getFn,
          fieldNormWeight: this.options.fieldNormWeight
        });
    }

    add(doc) {
      if (!isDefined(doc)) {
        return
      }

      this._docs.push(doc);
      this._myIndex.add(doc);
    }

    remove(predicate = (/* doc, idx */) => false) {
      const results = [];

      for (let i = 0, len = this._docs.length; i < len; i += 1) {
        const doc = this._docs[i];
        if (predicate(doc, i)) {
          this.removeAt(i);
          i -= 1;
          len -= 1;

          results.push(doc);
        }
      }

      return results
    }

    removeAt(idx) {
      this._docs.splice(idx, 1);
      this._myIndex.removeAt(idx);
    }

    getIndex() {
      return this._myIndex
    }

    search(query, { limit = -1 } = {}) {
      const {
        includeMatches,
        includeScore,
        shouldSort,
        sortFn,
        ignoreFieldNorm
      } = this.options;

      let results = isString$1(query)
        ? isString$1(this._docs[0])
          ? this._searchStringList(query)
          : this._searchObjectList(query)
        : this._searchLogical(query);

      computeScore(results, { ignoreFieldNorm });

      if (shouldSort) {
        results.sort(sortFn);
      }

      if (isNumber$1(limit) && limit > -1) {
        results = results.slice(0, limit);
      }

      return format(results, this._docs, {
        includeMatches,
        includeScore
      })
    }

    _searchStringList(query) {
      const searcher = createSearcher(query, this.options);
      const { records } = this._myIndex;
      const results = [];

      // Iterate over every string in the index
      records.forEach(({ v: text, i: idx, n: norm }) => {
        if (!isDefined(text)) {
          return
        }

        const { isMatch, score, indices } = searcher.searchIn(text);

        if (isMatch) {
          results.push({
            item: text,
            idx,
            matches: [{ score, value: text, norm, indices }]
          });
        }
      });

      return results
    }

    _searchLogical(query) {

      const expression = parse(query, this.options);

      const evaluate = (node, item, idx) => {
        if (!node.children) {
          const { keyId, searcher } = node;

          const matches = this._findMatches({
            key: this._keyStore.get(keyId),
            value: this._myIndex.getValueForItemAtKeyId(item, keyId),
            searcher
          });

          if (matches && matches.length) {
            return [
              {
                idx,
                item,
                matches
              }
            ]
          }

          return []
        }

        const res = [];
        for (let i = 0, len = node.children.length; i < len; i += 1) {
          const child = node.children[i];
          const result = evaluate(child, item, idx);
          if (result.length) {
            res.push(...result);
          } else if (node.operator === LogicalOperator.AND) {
            return []
          }
        }
        return res
      };

      const records = this._myIndex.records;
      const resultMap = {};
      const results = [];

      records.forEach(({ $: item, i: idx }) => {
        if (isDefined(item)) {
          let expResults = evaluate(expression, item, idx);

          if (expResults.length) {
            // Dedupe when adding
            if (!resultMap[idx]) {
              resultMap[idx] = { idx, item, matches: [] };
              results.push(resultMap[idx]);
            }
            expResults.forEach(({ matches }) => {
              resultMap[idx].matches.push(...matches);
            });
          }
        }
      });

      return results
    }

    _searchObjectList(query) {
      const searcher = createSearcher(query, this.options);
      const { keys, records } = this._myIndex;
      const results = [];

      // List is Array<Object>
      records.forEach(({ $: item, i: idx }) => {
        if (!isDefined(item)) {
          return
        }

        let matches = [];

        // Iterate over every key (i.e, path), and fetch the value at that key
        keys.forEach((key, keyIndex) => {
          matches.push(
            ...this._findMatches({
              key,
              value: item[keyIndex],
              searcher
            })
          );
        });

        if (matches.length) {
          results.push({
            idx,
            item,
            matches
          });
        }
      });

      return results
    }
    _findMatches({ key, value, searcher }) {
      if (!isDefined(value)) {
        return []
      }

      let matches = [];

      if (isArray(value)) {
        value.forEach(({ v: text, i: idx, n: norm }) => {
          if (!isDefined(text)) {
            return
          }

          const { isMatch, score, indices } = searcher.searchIn(text);

          if (isMatch) {
            matches.push({
              score,
              key,
              value: text,
              idx,
              norm,
              indices
            });
          }
        });
      } else {
        const { v: text, n: norm } = value;

        const { isMatch, score, indices } = searcher.searchIn(text);

        if (isMatch) {
          matches.push({ score, key, value: text, norm, indices });
        }
      }

      return matches
    }
  }

  Fuse.version = '6.6.2';
  Fuse.createIndex = createIndex;
  Fuse.parseIndex = parseIndex;
  Fuse.config = Config;

  {
    Fuse.parseQuery = parse;
  }

  {
    register(ExtendedSearch);
  }

  class FuseJS {
    /**
     * @type Ref
     */
    fuse;
    /**
     * @type Ref
     */
    resultsRaw;
    /**
     * @type ComputedRef
     */
    results;
    /**
     * @type Ref
     */
    search;
    /**
     * @type ComputedRef
     */
    noResults;
    /**
     * @param items
     * @param options
     */
    /**
     * It takes an array of items and an optional FuseOptions object, and then it creates a new Fuse instance with those
     * items and options, and then it runs the search with the current search value
     * @param items - DataT[] - The items to search through.
     * @param options - FuseOptions<DataT>
     */
    loadItems(items, options) {
      this.fuse = vueDemi.ref(new Fuse(items, options));
      this.runSearch(this.search.value);
    }
    /**
     * If there is no search string, clear the results. Otherwise, search the fuse
     * @param {string} [search] - The search string to use.
     * @returns The results of the search.
     */
    runSearch(search) {
      if (!this.fuse) {
        return;
      }
      if (!search) {
        this.resultsRaw.value = [];
        return;
      }
      this.resultsRaw.value = this.fuse.value.search(search);
    }
    /**
     * We create a new Fuse instance with the list of items and options, and then we create a computed property that returns
     * the results of the search
     * @param list - This is the list of items that you want to search. It can be an array of items, or a reactive object
     * that contains an array of items.
     * @param options - FuseOptions<DataT>
     */
    constructor(list, options) {
      this.search = vueDemi.ref("");
      let locArr = [];
      if (Array.isArray(list)) {
        locArr = list;
      } else if (list) {
        locArr = list.value ?? [];
        vueDemi.watch(list, () => {
          this.loadItems(list.value ?? []);
        });
      }
      this.fuse = vueDemi.ref(new Fuse(locArr, options));
      this.resultsRaw = vueDemi.ref([]);
      this.noResults = vueDemi.computed(() => {
        return this.results.value.length === 0 && this.search.value.length > 0;
      });
      this.results = vueDemi.computed(() => this.resultsRaw.value.map((r) => r.item));
      vueDemi.watch(this.search, this.runSearch);
    }
  }
  function useFuseJs(list, options) {
    return new FuseJS(list, options);
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  const toString = (val) => Object.prototype.toString.call(val);
  const noop = () => {
  };

  const isDef = (val) => typeof val !== "undefined";
  const isFunction = (val) => typeof val === "function";
  const isNumber = (val) => typeof val === "number";
  const isString = (val) => typeof val === "string";
  const isObject = (val) => toString(val) === "[object Object]";

  function objectKeys(obj) {
    return Object.keys(obj);
  }
  function objectEntries(obj) {
    return Object.entries(obj);
  }

  const isServer = () => typeof window === "undefined";
  const isClient = () => !isServer();
  const getDocument = () => typeof document === "undefined" ? void 0 : document;

  function setProps(modifiers, props) {
    modifiers.forEach((item) => {
      if (!isNumber(item)) {
        props.event = item;
      } else {
        props.transition = item;
      }
    });
  }
  function rippleHandler(el, modifiers, options) {
    const props = {
      event: "mousedown",
      transition: 600
    };
    setProps(objectKeys(modifiers), props);
    el.addEventListener(props.event, (event) => {
      rippleEl(event, el);
    });
    const bg = options?.color || "rgba(0, 0, 0, 0.35)";
    const zIndex = options?.zIndex || "9999";
    const rippleEl = function(event, el2) {
      const target = el2;
      const targetBorder = parseInt(getComputedStyle(target).borderWidth.replace("px", ""));
      const clientX = event.clientX || event.touches[0].clientX;
      const clientY = event.clientY || event.touches[0].clientY;
      const rect = target.getBoundingClientRect();
      const left = rect.left;
      const top = rect.top;
      const width = target.offsetWidth;
      const height = target.offsetHeight;
      const dx = clientX - left;
      const dy = clientY - top;
      const maxX = Math.max(dx, width - dx);
      const maxY = Math.max(dy, height - dy);
      const style = window.getComputedStyle(target);
      const radius = Math.sqrt(maxX * maxX + maxY * maxY);
      const border = targetBorder > 0 ? targetBorder : 0;
      const ripple = document.createElement("div");
      const rippleContainer = document.createElement("div");
      rippleContainer.className = "ripple-container";
      ripple.className = "ripple";
      ripple.style.marginTop = "0px";
      ripple.style.marginLeft = "0px";
      ripple.style.width = "1px";
      ripple.style.height = "1px";
      ripple.style.transition = `all ${props.transition}ms cubic-bezier(0.4, 0, 0.2, 1)`;
      ripple.style.borderRadius = "50%";
      ripple.style.pointerEvents = "none";
      ripple.style.position = "relative";
      ripple.style.zIndex = zIndex;
      ripple.style.backgroundColor = bg;
      rippleContainer.style.position = "absolute";
      rippleContainer.style.left = `${0 - border}px`;
      rippleContainer.style.top = `${0 - border}px`;
      rippleContainer.style.height = "0";
      rippleContainer.style.width = "0";
      rippleContainer.style.pointerEvents = "none";
      rippleContainer.style.overflow = "hidden";
      const storedTargetPosition = target.style.position.length > 0 ? target.style.position : getComputedStyle(target).position;
      if (storedTargetPosition !== "relative") {
        target.style.position = "relative";
      }
      rippleContainer.appendChild(ripple);
      target.appendChild(rippleContainer);
      ripple.style.marginLeft = `${dx}px`;
      ripple.style.marginTop = `${dy}px`;
      rippleContainer.style.width = `${width}px`;
      rippleContainer.style.height = `${height}px`;
      rippleContainer.style.borderTopLeftRadius = style.borderTopLeftRadius;
      rippleContainer.style.borderTopRightRadius = style.borderTopRightRadius;
      rippleContainer.style.borderBottomLeftRadius = style.borderBottomLeftRadius;
      rippleContainer.style.borderBottomRightRadius = style.borderBottomRightRadius;
      rippleContainer.style.direction = "ltr";
      setTimeout(() => {
        ripple.style.width = `${radius * 2}px`;
        ripple.style.height = `${radius * 2}px`;
        ripple.style.marginLeft = `${dx - radius}px`;
        ripple.style.marginTop = `${dy - radius}px`;
      }, 0);
      function clearRipple() {
        setTimeout(() => {
          ripple.style.backgroundColor = "rgba(0, 0, 0, 0)";
        }, 250);
        setTimeout(() => {
          rippleContainer.parentNode?.removeChild(rippleContainer);
        }, 850);
        el2.removeEventListener("mouseup", clearRipple, false);
        el2.removeEventListener("mouseleave", clearRipple, false);
        el2.removeEventListener("dragstart", clearRipple, false);
        setTimeout(() => {
          let clearPosition = true;
          for (const child of target.childNodes) {
            if (child.className === "ripple-container") {
              clearPosition = false;
            }
          }
          if (clearPosition) {
            if (storedTargetPosition !== "static") {
              target.style.position = storedTargetPosition;
            } else {
              target.style.position = "";
            }
          }
        }, props.transition + 250);
      }
      if (event.type === "mousedown") {
        el2.addEventListener("mouseup", clearRipple, false);
        el2.addEventListener("mouseleave", clearRipple, false);
        el2.addEventListener("dragstart", clearRipple, false);
      } else {
        clearRipple();
      }
    };
  }
  function makeRippleDir(options = {}) {
    return {
      [`${vueDemi.isVue3 ? "beforeMount" : "bind"}`]: (el, binding) => rippleHandler(
        el,
        binding.modifiers,
        { ...options, color: binding.value }
      )
    };
  }
  const vRipple = makeRippleDir();
  function useRipple(el, event, options) {
    const element = el instanceof HTMLElement ? el : el.value;
    rippleHandler(element, event ? { [event]: true } : { mousedown: true }, options);
  }
  const Ripple = {
    install(app, options) {
      app.directive("ripple", makeRippleDir(options));
    }
  };

  function refOf(r) {
    return typeof r === "function" ? vueDemi.computed(r) : vueDemi.ref(r);
  }

  function unrefOf(r) {
    return typeof r === "function" ? r() : vueDemi.unref(r);
  }

  function unrefElement(elRef) {
    const plain = unrefOf(elRef);
    return plain?.$el ?? plain;
  }

  const defaultWindow = /* @__PURE__ */ isClient() ? window : void 0;
  const defaultDocument = /* @__PURE__ */ isClient() ? window.document : void 0;

  function tryOnScopeDispose(func) {
    if (vueDemi.getCurrentScope()) {
      vueDemi.onScopeDispose(func);
      return true;
    }
    return false;
  }

  function listenEvent(...args) {
    let target;
    let events;
    let listeners;
    let options;
    if (isString(args[0]) || Array.isArray(args[0])) {
      [events, listeners, options] = args;
      target = defaultWindow;
    } else {
      [target, events, listeners, options] = args;
    }
    if (!target) {
      return noop;
    }
    if (!Array.isArray(events)) {
      events = [events];
    }
    if (!Array.isArray(listeners)) {
      listeners = [listeners];
    }
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
    };
    const register = (el, event, listener) => {
      el.addEventListener(event, listener, options);
      return () => el.removeEventListener(event, listener, options);
    };
    const stopWatch = vueDemi.watch(
      () => unrefElement(target),
      (el) => {
        cleanup();
        if (!el) {
          return;
        }
        cleanups.push(
          ...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener));
          })
        );
      },
      { immediate: true, flush: "post" }
    );
    const stop = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose(stop);
    return stop;
  }

  function tryOnMounted(func, sync = true) {
    if (vueDemi.getCurrentInstance()) {
      vueDemi.onMounted(() => func());
    } else if (sync) {
      func();
    } else {
      vueDemi.nextTick(() => func());
    }
  }

  function tryOnUnmounted(func) {
    if (vueDemi.getCurrentInstance()) {
      vueDemi.onUnmounted(func);
    }
  }

  let _id$1 = 0;
  function useLinkTag(href, onLoaded = noop, options = {}) {
    const {
      as,
      media,
      crossOrigin,
      referrerPolicy,
      blocking,
      immediate = true,
      manual = false,
      attrs = {},
      type = "text/css",
      rel = "stylesheet",
      id = `use_link_tag_${++_id$1}`,
      document = getDocument()
    } = options;
    const linkTag = vueDemi.ref();
    const loaded = vueDemi.ref();
    let _promise = null;
    const _evtListeners = {};
    const findLinkEl = () => document.querySelector(`link[id="${id}"]`);
    const loadLink = (waitForLoad) => new Promise((resolve, reject) => {
      const resolveWithElement = (el2) => {
        linkTag.value = el2;
        resolve(el2);
        return el2;
      };
      if (!document) {
        resolve(false);
        return;
      }
      let shouldAppend = false;
      let el = findLinkEl();
      if (!el) {
        el = document.createElement("link");
        el.id = id;
        el.rel = rel;
        el.type = type;
        el.href = unrefOf(href);
        if (as) {
          el.as = as;
        }
        if (media) {
          el.media = media;
        }
        if (crossOrigin) {
          el.crossOrigin = crossOrigin;
        }
        if (referrerPolicy) {
          el.referrerPolicy = referrerPolicy;
        }
        if (blocking) {
          attrs.blocking = blocking;
        }
        objectEntries(attrs).forEach(([name, value]) => el?.setAttribute(name, value));
        shouldAppend = true;
      } else if (el.hasAttribute("data-loaded")) {
        resolveWithElement(el);
      }
      _evtListeners.error = listenEvent(el, "error", (event) => reject(event));
      _evtListeners.abort = listenEvent(el, "abort", (event) => reject(event));
      _evtListeners.load = listenEvent(el, "load", () => {
        el.setAttribute("data-loaded", "true");
        loaded.value = true;
        onLoaded(el);
        resolveWithElement(el);
      });
      if (shouldAppend) {
        el = document.head.appendChild(el);
      }
      if (!waitForLoad) {
        resolveWithElement(el);
      }
    });
    const load = (waitForLoad = true) => {
      if (!_promise) {
        _promise = loadLink(waitForLoad);
      }
      return _promise;
    };
    const unload = () => {
      if (!document) {
        return;
      }
      _promise = null;
      if (linkTag.value) {
        linkTag.value = void 0;
      }
      const el = findLinkEl();
      if (el) {
        objectEntries(_evtListeners).forEach(([name, unregister]) => {
          unregister();
        });
        document.head.removeChild(el);
      }
      loaded.value = void 0;
    };
    const update = () => {
      const el = findLinkEl();
      if (el) {
        el.href = unrefOf(href);
      }
    };
    if (immediate && !manual) {
      tryOnMounted(load);
    }
    if (!manual) {
      tryOnUnmounted(unload);
    }
    vueDemi.watch(
      () => unrefOf(href),
      update,
      { immediate: true, flush: "post" }
    );
    return { linkTag, loaded, load, unload };
  }

  let _id = 0;
  function useStyleTag(css, options = {}) {
    const isLoaded = vueDemi.ref(false);
    const {
      document = defaultDocument,
      immediate = true,
      manual = false,
      id = `whoj.utils-vue_style_tag_${++_id}`
    } = options;
    const cssRef = vueDemi.ref(css);
    let stop = () => {
    };
    const load = () => {
      if (!document) {
        return;
      }
      const el = document.getElementById(id) || document.createElement("style");
      if (!el.isConnected) {
        el.type = "text/css";
        el.id = id;
        if (options.media) {
          el.media = options.media;
        }
        document.head.appendChild(el);
      }
      if (isLoaded.value) {
        return;
      }
      stop = vueDemi.watch(
        cssRef,
        (value) => {
          el.textContent = value;
        },
        { immediate: true }
      );
      isLoaded.value = true;
    };
    const unload = () => {
      if (!document || !isLoaded.value) {
        return;
      }
      stop();
      document.head.removeChild(document.getElementById(id));
      isLoaded.value = false;
    };
    if (immediate && !manual) {
      tryOnMounted(load);
    }
    if (!manual) {
      tryOnScopeDispose(unload);
    }
    return {
      id,
      css: cssRef,
      unload,
      load,
      isLoaded: vueDemi.readonly(isLoaded)
    };
  }

  var resumable = {exports: {}};

  /*
  * MIT Licensed
  * http://www.23developer.com/opensource
  * http://github.com/23/resumable.js
  * Steffen Tiedemann Christensen, steffen@23company.com
  */

  (function (module) {
  	(function(){

  	  var Resumable = function(opts){
  	    if ( !(this instanceof Resumable) ) {
  	      return new Resumable(opts);
  	    }
  	    this.version = 1.0;
  	    // SUPPORTED BY BROWSER?
  	    // Check if these features are support by the browser:
  	    // - File object type
  	    // - Blob object type
  	    // - FileList object type
  	    // - slicing files
  	    this.support = (
  	                   (typeof(File)!=='undefined')
  	                   &&
  	                   (typeof(Blob)!=='undefined')
  	                   &&
  	                   (typeof(FileList)!=='undefined')
  	                   &&
  	                   (!!Blob.prototype.webkitSlice||!!Blob.prototype.mozSlice||!!Blob.prototype.slice||false)
  	                   );
  	    if(!this.support) return(false);


  	    // PROPERTIES
  	    var $ = this;
  	    $.files = [];
  	    $.defaults = {
  	      chunkSize:1*1024*1024,
  	      forceChunkSize:false,
  	      simultaneousUploads:3,
  	      fileParameterName:'file',
  	      chunkNumberParameterName: 'resumableChunkNumber',
  	      chunkSizeParameterName: 'resumableChunkSize',
  	      currentChunkSizeParameterName: 'resumableCurrentChunkSize',
  	      totalSizeParameterName: 'resumableTotalSize',
  	      typeParameterName: 'resumableType',
  	      identifierParameterName: 'resumableIdentifier',
  	      fileNameParameterName: 'resumableFilename',
  	      relativePathParameterName: 'resumableRelativePath',
  	      totalChunksParameterName: 'resumableTotalChunks',
  	      throttleProgressCallbacks: 0.5,
  	      query:{},
  	      headers:{},
  	      preprocess:null,
  	      method:'multipart',
  	      uploadMethod: 'POST',
  	      testMethod: 'GET',
  	      prioritizeFirstAndLastChunk:false,
  	      target:'/',
  	      testTarget: null,
  	      parameterNamespace:'',
  	      testChunks:true,
  	      generateUniqueIdentifier:null,
  	      getTarget:null,
  	      maxChunkRetries:100,
  	      chunkRetryInterval:undefined,
  	      permanentErrors:[400, 404, 415, 500, 501],
  	      maxFiles:undefined,
  	      withCredentials:false,
  	      xhrTimeout:0,
  	      clearInput:true,
  	      chunkFormat:'blob',
  	      setChunkTypeFromFile:false,
  	      maxFilesErrorCallback:function (files, errorCount) {
  	        var maxFiles = $.getOpt('maxFiles');
  	        alert('Please upload no more than ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');
  	      },
  	      minFileSize:1,
  	      minFileSizeErrorCallback:function(file, errorCount) {
  	        alert(file.fileName||file.name +' is too small, please upload files larger than ' + $h.formatSize($.getOpt('minFileSize')) + '.');
  	      },
  	      maxFileSize:undefined,
  	      maxFileSizeErrorCallback:function(file, errorCount) {
  	        alert(file.fileName||file.name +' is too large, please upload files less than ' + $h.formatSize($.getOpt('maxFileSize')) + '.');
  	      },
  	      fileType: [],
  	      fileTypeErrorCallback: function(file, errorCount) {
  	        alert(file.fileName||file.name +' has type not allowed, please upload files of type ' + $.getOpt('fileType') + '.');
  	      }
  	    };
  	    $.opts = opts||{};
  	    $.getOpt = function(o) {
  	      var $opt = this;
  	      // Get multiple option if passed an array
  	      if(o instanceof Array) {
  	        var options = {};
  	        $h.each(o, function(option){
  	          options[option] = $opt.getOpt(option);
  	        });
  	        return options;
  	      }
  	      // Otherwise, just return a simple option
  	      if ($opt instanceof ResumableChunk) {
  	        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }
  	        else { $opt = $opt.fileObj; }
  	      }
  	      if ($opt instanceof ResumableFile) {
  	        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }
  	        else { $opt = $opt.resumableObj; }
  	      }
  	      if ($opt instanceof Resumable) {
  	        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }
  	        else { return $opt.defaults[o]; }
  	      }
  	    };

  	    // EVENTS
  	    // catchAll(event, ...)
  	    // fileSuccess(file), fileProgress(file), fileAdded(file, event), filesAdded(files, filesSkipped), fileRetry(file),
  	    // fileError(file, message), complete(), progress(), error(message, file), pause()
  	    $.events = [];
  	    $.on = function(event,callback){
  	      $.events.push(event.toLowerCase(), callback);
  	    };
  	    $.fire = function(){
  	      // `arguments` is an object, not array, in FF, so:
  	      var args = [];
  	      for (var i=0; i<arguments.length; i++) args.push(arguments[i]);
  	      // Find event listeners, and support pseudo-event `catchAll`
  	      var event = args[0].toLowerCase();
  	      for (var i=0; i<=$.events.length; i+=2) {
  	        if($.events[i]==event) $.events[i+1].apply($,args.slice(1));
  	        if($.events[i]=='catchall') $.events[i+1].apply(null,args);
  	      }
  	      if(event=='fileerror') $.fire('error', args[2], args[1]);
  	      if(event=='fileprogress') $.fire('progress');
  	    };


  	    // INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)
  	    var $h = {
  	      stopEvent: function(e){
  	        e.stopPropagation();
  	        e.preventDefault();
  	      },
  	      each: function(o,callback){
  	        if(typeof(o.length)!=='undefined') {
  	          for (var i=0; i<o.length; i++) {
  	            // Array or FileList
  	            if(callback(o[i])===false) return;
  	          }
  	        } else {
  	          for (i in o) {
  	            // Object
  	            if(callback(i,o[i])===false) return;
  	          }
  	        }
  	      },
  	      generateUniqueIdentifier:function(file, event){
  	        var custom = $.getOpt('generateUniqueIdentifier');
  	        if(typeof custom === 'function') {
  	          return custom(file, event);
  	        }
  	        var relativePath = file.webkitRelativePath||file.fileName||file.name; // Some confusion in different versions of Firefox
  	        var size = file.size;
  	        return(size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));
  	      },
  	      contains:function(array,test) {
  	        var result = false;

  	        $h.each(array, function(value) {
  	          if (value == test) {
  	            result = true;
  	            return false;
  	          }
  	          return true;
  	        });

  	        return result;
  	      },
  	      formatSize:function(size){
  	        if(size<1024) {
  	          return size + ' bytes';
  	        } else if(size<1024*1024) {
  	          return (size/1024.0).toFixed(0) + ' KB';
  	        } else if(size<1024*1024*1024) {
  	          return (size/1024.0/1024.0).toFixed(1) + ' MB';
  	        } else {
  	          return (size/1024.0/1024.0/1024.0).toFixed(1) + ' GB';
  	        }
  	      },
  	      getTarget:function(request, params){
  	        var target = $.getOpt('target');

  	        if (request === 'test' && $.getOpt('testTarget')) {
  	          target = $.getOpt('testTarget') === '/' ? $.getOpt('target') : $.getOpt('testTarget');
  	        }

  	        if (typeof target === 'function') {
  	          return target(params);
  	        }

  	        var separator = target.indexOf('?') < 0 ? '?' : '&';
  	        var joinedParams = params.join('&');

  	        return target + separator + joinedParams;
  	      }
  	    };

  	    var onDrop = function(event){
  	      $h.stopEvent(event);

  	      //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)
  	      if (event.dataTransfer && event.dataTransfer.items) {
  	        loadFiles(event.dataTransfer.items, event);
  	      }
  	      //else handle them as files
  	      else if (event.dataTransfer && event.dataTransfer.files) {
  	        loadFiles(event.dataTransfer.files, event);
  	      }
  	    };
  	    var preventDefault = function(e) {
  	      e.preventDefault();
  	    };

  	    /**
  	     * processes a single upload item (file or directory)
  	     * @param {Object} item item to upload, may be file or directory entry
  	     * @param {string} path current file path
  	     * @param {File[]} items list of files to append new items to
  	     * @param {Function} cb callback invoked when item is processed
  	     */
  	    function processItem(item, path, items, cb) {
  	      var entry;
  	      if(item.isFile){
  	        // file provided
  	        return item.file(function(file){
  	          file.relativePath = path + file.name;
  	          items.push(file);
  	          cb();
  	        });
  	      }else if(item.isDirectory){
  	        // item is already a directory entry, just assign
  	        entry = item;
  	      }else if(item instanceof File) {
  	        items.push(item);
  	      }
  	      if('function' === typeof item.webkitGetAsEntry){
  	        // get entry from file object
  	        entry = item.webkitGetAsEntry();
  	      }
  	      if(entry && entry.isDirectory){
  	        // directory provided, process it
  	        return processDirectory(entry, path + entry.name + '/', items, cb);
  	      }
  	      if('function' === typeof item.getAsFile){
  	        // item represents a File object, convert it
  	        item = item.getAsFile();
  	        if(item instanceof File) {
  	          item.relativePath = path + item.name;
  	          items.push(item);
  	        }
  	      }
  	      cb(); // indicate processing is done
  	    }


  	    /**
  	     * cps-style list iteration.
  	     * invokes all functions in list and waits for their callback to be
  	     * triggered.
  	     * @param  {Function[]}   items list of functions expecting callback parameter
  	     * @param  {Function} cb    callback to trigger after the last callback has been invoked
  	     */
  	    function processCallbacks(items, cb){
  	      if(!items || items.length === 0){
  	        // empty or no list, invoke callback
  	        return cb();
  	      }
  	      // invoke current function, pass the next part as continuation
  	      items[0](function(){
  	        processCallbacks(items.slice(1), cb);
  	      });
  	    }

  	    /**
  	     * recursively traverse directory and collect files to upload
  	     * @param  {Object}   directory directory to process
  	     * @param  {string}   path      current path
  	     * @param  {File[]}   items     target list of items
  	     * @param  {Function} cb        callback invoked after traversing directory
  	     */
  	    function processDirectory (directory, path, items, cb) {
  	      var dirReader = directory.createReader();
  	      dirReader.readEntries(function(entries){
  	        if(!entries.length){
  	          // empty directory, skip
  	          return cb();
  	        }
  	        // process all conversion callbacks, finally invoke own one
  	        processCallbacks(
  	          entries.map(function(entry){
  	            // bind all properties except for callback
  	            return processItem.bind(null, entry, path, items);
  	          }),
  	          cb
  	        );
  	      });
  	    }

  	    /**
  	     * process items to extract files to be uploaded
  	     * @param  {File[]} items items to process
  	     * @param  {Event} event event that led to upload
  	     */
  	    function loadFiles(items, event) {
  	      if(!items.length){
  	        return; // nothing to do
  	      }
  	      $.fire('beforeAdd');
  	      var files = [];
  	      processCallbacks(
  	          Array.prototype.map.call(items, function(item){
  	            // bind all properties except for callback
  	            return processItem.bind(null, item, "", files);
  	          }),
  	          function(){
  	            if(files.length){
  	              // at least one file found
  	              appendFilesFromFileList(files, event);
  	            }
  	          }
  	      );
  	    }
  	    var appendFilesFromFileList = function(fileList, event){
  	      // check for uploading too many files
  	      var errorCount = 0;
  	      var o = $.getOpt(['maxFiles', 'minFileSize', 'maxFileSize', 'maxFilesErrorCallback', 'minFileSizeErrorCallback', 'maxFileSizeErrorCallback', 'fileType', 'fileTypeErrorCallback']);
  	      if (typeof(o.maxFiles)!=='undefined' && o.maxFiles<(fileList.length+$.files.length)) {
  	        // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file
  	        if (o.maxFiles===1 && $.files.length===1 && fileList.length===1) {
  	          $.removeFile($.files[0]);
  	        } else {
  	          o.maxFilesErrorCallback(fileList, errorCount++);
  	          return false;
  	        }
  	      }
  	      var files = [], filesSkipped = [], remaining = fileList.length;
  	      var decreaseReamining = function(){
  	        if(!--remaining){
  	          // all files processed, trigger event
  	          if(!files.length && !filesSkipped.length){
  	            // no succeeded files, just skip
  	            return;
  	          }
  	          window.setTimeout(function(){
  	            $.fire('filesAdded', files, filesSkipped);
  	          },0);
  	        }
  	      };
  	      $h.each(fileList, function(file){
  	        var fileName = file.name;
  	        if(o.fileType.length > 0){
  	          var fileTypeFound = false;
  	          for(var index in o.fileType){
  	            var extension = '.' + o.fileType[index];
  				if(fileName.toLowerCase().indexOf(extension.toLowerCase(), fileName.length - extension.length) !== -1){
  	              fileTypeFound = true;
  	              break;
  	            }
  	          }
  	          if (!fileTypeFound) {
  	            o.fileTypeErrorCallback(file, errorCount++);
  	            return false;
  	          }
  	        }

  	        if (typeof(o.minFileSize)!=='undefined' && file.size<o.minFileSize) {
  	          o.minFileSizeErrorCallback(file, errorCount++);
  	          return false;
  	        }
  	        if (typeof(o.maxFileSize)!=='undefined' && file.size>o.maxFileSize) {
  	          o.maxFileSizeErrorCallback(file, errorCount++);
  	          return false;
  	        }

  	        function addFile(uniqueIdentifier){
  	          if (!$.getFromUniqueIdentifier(uniqueIdentifier)) {(function(){
  	            file.uniqueIdentifier = uniqueIdentifier;
  	            var f = new ResumableFile($, file, uniqueIdentifier);
  	            $.files.push(f);
  	            files.push(f);
  	            f.container = (typeof event != 'undefined' ? event.srcElement : null);
  	            window.setTimeout(function(){
  	              $.fire('fileAdded', f, event);
  	            },0);
  	          })();} else {
  	            filesSkipped.push(file);
  	          }	          decreaseReamining();
  	        }
  	        // directories have size == 0
  	        var uniqueIdentifier = $h.generateUniqueIdentifier(file, event);
  	        if(uniqueIdentifier && typeof uniqueIdentifier.then === 'function'){
  	          // Promise or Promise-like object provided as unique identifier
  	          uniqueIdentifier
  	          .then(
  	            function(uniqueIdentifier){
  	              // unique identifier generation succeeded
  	              addFile(uniqueIdentifier);
  	            },
  	           function(){
  	              // unique identifier generation failed
  	              // skip further processing, only decrease file count
  	              decreaseReamining();
  	            }
  	          );
  	        }else {
  	          // non-Promise provided as unique identifier, process synchronously
  	          addFile(uniqueIdentifier);
  	        }
  	      });
  	    };

  	    // INTERNAL OBJECT TYPES
  	    function ResumableFile(resumableObj, file, uniqueIdentifier){
  	      var $ = this;
  	      $.opts = {};
  	      $.getOpt = resumableObj.getOpt;
  	      $._prevProgress = 0;
  	      $.resumableObj = resumableObj;
  	      $.file = file;
  	      $.fileName = file.fileName||file.name; // Some confusion in different versions of Firefox
  	      $.size = file.size;
  	      $.relativePath = file.relativePath || file.webkitRelativePath || $.fileName;
  	      $.uniqueIdentifier = uniqueIdentifier;
  	      $._pause = false;
  	      $.container = '';
  	      var _error = uniqueIdentifier !== undefined;

  	      // Callback when something happens within the chunk
  	      var chunkEvent = function(event, message){
  	        // event can be 'progress', 'success', 'error' or 'retry'
  	        switch(event){
  	        case 'progress':
  	          $.resumableObj.fire('fileProgress', $, message);
  	          break;
  	        case 'error':
  	          $.abort();
  	          _error = true;
  	          $.chunks = [];
  	          $.resumableObj.fire('fileError', $, message);
  	          break;
  	        case 'success':
  	          if(_error) return;
  	          $.resumableObj.fire('fileProgress', $); // it's at least progress
  	          if($.isComplete()) {
  	            $.resumableObj.fire('fileSuccess', $, message);
  	          }
  	          break;
  	        case 'retry':
  	          $.resumableObj.fire('fileRetry', $);
  	          break;
  	        }
  	      };

  	      // Main code to set up a file object with chunks,
  	      // packaged to be able to handle retries if needed.
  	      $.chunks = [];
  	      $.abort = function(){
  	        // Stop current uploads
  	        var abortCount = 0;
  	        $h.each($.chunks, function(c){
  	          if(c.status()=='uploading') {
  	            c.abort();
  	            abortCount++;
  	          }
  	        });
  	        if(abortCount>0) $.resumableObj.fire('fileProgress', $);
  	      };
  	      $.cancel = function(){
  	        // Reset this file to be void
  	        var _chunks = $.chunks;
  	        $.chunks = [];
  	        // Stop current uploads
  	        $h.each(_chunks, function(c){
  	          if(c.status()=='uploading')  {
  	            c.abort();
  	            $.resumableObj.uploadNextChunk();
  	          }
  	        });
  	        $.resumableObj.removeFile($);
  	        $.resumableObj.fire('fileProgress', $);
  	      };
  	      $.retry = function(){
  	        $.bootstrap();
  	        var firedRetry = false;
  	        $.resumableObj.on('chunkingComplete', function(){
  	          if(!firedRetry) $.resumableObj.upload();
  	          firedRetry = true;
  	        });
  	      };
  	      $.bootstrap = function(){
  	        $.abort();
  	        _error = false;
  	        // Rebuild stack of chunks from file
  	        $.chunks = [];
  	        $._prevProgress = 0;
  	        var round = $.getOpt('forceChunkSize') ? Math.ceil : Math.floor;
  	        var maxOffset = Math.max(round($.file.size/$.getOpt('chunkSize')),1);
  	        for (var offset=0; offset<maxOffset; offset++) {(function(offset){
  	            window.setTimeout(function(){
  	                $.chunks.push(new ResumableChunk($.resumableObj, $, offset, chunkEvent));
  	                $.resumableObj.fire('chunkingProgress',$,offset/maxOffset);
  	            },0);
  	        })(offset);}
  	        window.setTimeout(function(){
  	            $.resumableObj.fire('chunkingComplete',$);
  	        },0);
  	      };
  	      $.progress = function(){
  	        if(_error) return(1);
  	        // Sum up progress across everything
  	        var ret = 0;
  	        var error = false;
  	        $h.each($.chunks, function(c){
  	          if(c.status()=='error') error = true;
  	          ret += c.progress(true); // get chunk progress relative to entire file
  	        });
  	        ret = (error ? 1 : (ret>0.99999 ? 1 : ret));
  	        ret = Math.max($._prevProgress, ret); // We don't want to lose percentages when an upload is paused
  	        $._prevProgress = ret;
  	        return(ret);
  	      };
  	      $.isUploading = function(){
  	        var uploading = false;
  	        $h.each($.chunks, function(chunk){
  	          if(chunk.status()=='uploading') {
  	            uploading = true;
  	            return(false);
  	          }
  	        });
  	        return(uploading);
  	      };
  	      $.isComplete = function(){
  	        var outstanding = false;
  	        $h.each($.chunks, function(chunk){
  	          var status = chunk.status();
  	          if(status=='pending' || status=='uploading' || chunk.preprocessState === 1) {
  	            outstanding = true;
  	            return(false);
  	          }
  	        });
  	        return(!outstanding);
  	      };
  	      $.pause = function(pause){
  	          if(typeof(pause)==='undefined'){
  	              $._pause = ($._pause ? false : true);
  	          }else {
  	              $._pause = pause;
  	          }
  	      };
  	      $.isPaused = function() {
  	        return $._pause;
  	      };


  	      // Bootstrap and return
  	      $.resumableObj.fire('chunkingStart', $);
  	      $.bootstrap();
  	      return(this);
  	    }


  	    function ResumableChunk(resumableObj, fileObj, offset, callback){
  	      var $ = this;
  	      $.opts = {};
  	      $.getOpt = resumableObj.getOpt;
  	      $.resumableObj = resumableObj;
  	      $.fileObj = fileObj;
  	      $.fileObjSize = fileObj.size;
  	      $.fileObjType = fileObj.file.type;
  	      $.offset = offset;
  	      $.callback = callback;
  	      $.lastProgressCallback = (new Date);
  	      $.tested = false;
  	      $.retries = 0;
  	      $.pendingRetry = false;
  	      $.preprocessState = 0; // 0 = unprocessed, 1 = processing, 2 = finished

  	      // Computed properties
  	      var chunkSize = $.getOpt('chunkSize');
  	      $.loaded = 0;
  	      $.startByte = $.offset*chunkSize;
  	      $.endByte = Math.min($.fileObjSize, ($.offset+1)*chunkSize);
  	      if ($.fileObjSize-$.endByte < chunkSize && !$.getOpt('forceChunkSize')) {
  	        // The last chunk will be bigger than the chunk size, but less than 2*chunkSize
  	        $.endByte = $.fileObjSize;
  	      }
  	      $.xhr = null;

  	      // test() makes a GET request without any data to see if the chunk has already been uploaded in a previous session
  	      $.test = function(){
  	        // Set up request and listen for event
  	        $.xhr = new XMLHttpRequest();

  	        var testHandler = function(e){
  	          $.tested = true;
  	          var status = $.status();
  	          if(status=='success') {
  	            $.callback(status, $.message());
  	            $.resumableObj.uploadNextChunk();
  	          } else {
  	            $.send();
  	          }
  	        };
  	        $.xhr.addEventListener('load', testHandler, false);
  	        $.xhr.addEventListener('error', testHandler, false);
  	        $.xhr.addEventListener('timeout', testHandler, false);

  	        // Add data from the query options
  	        var params = [];
  	        var parameterNamespace = $.getOpt('parameterNamespace');
  	        var customQuery = $.getOpt('query');
  	        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);
  	        $h.each(customQuery, function(k,v){
  	          params.push([encodeURIComponent(parameterNamespace+k), encodeURIComponent(v)].join('='));
  	        });
  	        // Add extra data to identify chunk
  	        params = params.concat(
  	          [
  	            // define key/value pairs for additional parameters
  	            ['chunkNumberParameterName', $.offset + 1],
  	            ['chunkSizeParameterName', $.getOpt('chunkSize')],
  	            ['currentChunkSizeParameterName', $.endByte - $.startByte],
  	            ['totalSizeParameterName', $.fileObjSize],
  	            ['typeParameterName', $.fileObjType],
  	            ['identifierParameterName', $.fileObj.uniqueIdentifier],
  	            ['fileNameParameterName', $.fileObj.fileName],
  	            ['relativePathParameterName', $.fileObj.relativePath],
  	            ['totalChunksParameterName', $.fileObj.chunks.length]
  	          ].filter(function(pair){
  	            // include items that resolve to truthy values
  	            // i.e. exclude false, null, undefined and empty strings
  	            return $.getOpt(pair[0]);
  	          })
  	          .map(function(pair){
  	            // map each key/value pair to its final form
  	            return [
  	              parameterNamespace + $.getOpt(pair[0]),
  	              encodeURIComponent(pair[1])
  	            ].join('=');
  	          })
  	        );
  	        // Append the relevant chunk and send it
  	        $.xhr.open($.getOpt('testMethod'), $h.getTarget('test', params));
  	        $.xhr.timeout = $.getOpt('xhrTimeout');
  	        $.xhr.withCredentials = $.getOpt('withCredentials');
  	        // Add data from header options
  	        var customHeaders = $.getOpt('headers');
  	        if(typeof customHeaders === 'function') {
  	          customHeaders = customHeaders($.fileObj, $);
  	        }
  	        $h.each(customHeaders, function(k,v) {
  	          $.xhr.setRequestHeader(k, v);
  	        });
  	        $.xhr.send(null);
  	      };

  	      $.preprocessFinished = function(){
  	        $.preprocessState = 2;
  	        $.send();
  	      };

  	      // send() uploads the actual data in a POST call
  	      $.send = function(){
  	        var preprocess = $.getOpt('preprocess');
  	        if(typeof preprocess === 'function') {
  	          switch($.preprocessState) {
  	          case 0: $.preprocessState = 1; preprocess($); return;
  	          case 1: return;
  	          }
  	        }
  	        if($.getOpt('testChunks') && !$.tested) {
  	          $.test();
  	          return;
  	        }

  	        // Set up request and listen for event
  	        $.xhr = new XMLHttpRequest();

  	        // Progress
  	        $.xhr.upload.addEventListener('progress', function(e){
  	          if( (new Date) - $.lastProgressCallback > $.getOpt('throttleProgressCallbacks') * 1000 ) {
  	            $.callback('progress');
  	            $.lastProgressCallback = (new Date);
  	          }
  	          $.loaded=e.loaded||0;
  	        }, false);
  	        $.loaded = 0;
  	        $.pendingRetry = false;
  	        $.callback('progress');

  	        // Done (either done, failed or retry)
  	        var doneHandler = function(e){
  	          var status = $.status();
  	          if(status=='success'||status=='error') {
  	            $.callback(status, $.message());
  	            $.resumableObj.uploadNextChunk();
  	          } else {
  	            $.callback('retry', $.message());
  	            $.abort();
  	            $.retries++;
  	            var retryInterval = $.getOpt('chunkRetryInterval');
  	            if(retryInterval !== undefined) {
  	              $.pendingRetry = true;
  	              setTimeout($.send, retryInterval);
  	            } else {
  	              $.send();
  	            }
  	          }
  	        };
  	        $.xhr.addEventListener('load', doneHandler, false);
  	        $.xhr.addEventListener('error', doneHandler, false);
  	        $.xhr.addEventListener('timeout', doneHandler, false);

  	        // Set up the basic query data from Resumable
  	        var query = [
  	          ['chunkNumberParameterName', $.offset + 1],
  	          ['chunkSizeParameterName', $.getOpt('chunkSize')],
  	          ['currentChunkSizeParameterName', $.endByte - $.startByte],
  	          ['totalSizeParameterName', $.fileObjSize],
  	          ['typeParameterName', $.fileObjType],
  	          ['identifierParameterName', $.fileObj.uniqueIdentifier],
  	          ['fileNameParameterName', $.fileObj.fileName],
  	          ['relativePathParameterName', $.fileObj.relativePath],
  	          ['totalChunksParameterName', $.fileObj.chunks.length],
  	        ].filter(function(pair){
  	          // include items that resolve to truthy values
  	          // i.e. exclude false, null, undefined and empty strings
  	          return $.getOpt(pair[0]);
  	        })
  	        .reduce(function(query, pair){
  	          // assign query key/value
  	          query[$.getOpt(pair[0])] = pair[1];
  	          return query;
  	        }, {});
  	        // Mix in custom data
  	        var customQuery = $.getOpt('query');
  	        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);
  	        $h.each(customQuery, function(k,v){
  	          query[k] = v;
  	        });

  	        var func = ($.fileObj.file.slice ? 'slice' : ($.fileObj.file.mozSlice ? 'mozSlice' : ($.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice')));
  	        var bytes = $.fileObj.file[func]($.startByte, $.endByte, $.getOpt('setChunkTypeFromFile') ? $.fileObj.file.type : "");
  	        var data = null;
  	        var params = [];

  	        var parameterNamespace = $.getOpt('parameterNamespace');
  	                if ($.getOpt('method') === 'octet') {
  	                    // Add data from the query options
  	                    data = bytes;
  	                    $h.each(query, function (k, v) {
  	                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));
  	                    });
  	                } else {
  	                    // Add data from the query options
  	                    data = new FormData();
  	                    $h.each(query, function (k, v) {
  	                        data.append(parameterNamespace + k, v);
  	                        params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join('='));
  	                    });
  	                    if ($.getOpt('chunkFormat') == 'blob') {
  	                        data.append(parameterNamespace + $.getOpt('fileParameterName'), bytes, $.fileObj.fileName);
  	                    }
  	                    else if ($.getOpt('chunkFormat') == 'base64') {
  	                        var fr = new FileReader();
  	                        fr.onload = function (e) {
  	                            data.append(parameterNamespace + $.getOpt('fileParameterName'), fr.result);
  	                            $.xhr.send(data);
  	                        };
  	                        fr.readAsDataURL(bytes);
  	                    }
  	                }

  	        var target = $h.getTarget('upload', params);
  	        var method = $.getOpt('uploadMethod');

  	        $.xhr.open(method, target);
  	        if ($.getOpt('method') === 'octet') {
  	          $.xhr.setRequestHeader('Content-Type', 'application/octet-stream');
  	        }
  	        $.xhr.timeout = $.getOpt('xhrTimeout');
  	        $.xhr.withCredentials = $.getOpt('withCredentials');
  	        // Add data from header options
  	        var customHeaders = $.getOpt('headers');
  	        if(typeof customHeaders === 'function') {
  	          customHeaders = customHeaders($.fileObj, $);
  	        }

  	        $h.each(customHeaders, function(k,v) {
  	          $.xhr.setRequestHeader(k, v);
  	        });

  	                if ($.getOpt('chunkFormat') == 'blob') {
  	                    $.xhr.send(data);
  	                }
  	      };
  	      $.abort = function(){
  	        // Abort and reset
  	        if($.xhr) $.xhr.abort();
  	        $.xhr = null;
  	      };
  	      $.status = function(){
  	        // Returns: 'pending', 'uploading', 'success', 'error'
  	        if($.pendingRetry) {
  	          // if pending retry then that's effectively the same as actively uploading,
  	          // there might just be a slight delay before the retry starts
  	          return('uploading');
  	        } else if(!$.xhr) {
  	          return('pending');
  	        } else if($.xhr.readyState<4) {
  	          // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening
  	          return('uploading');
  	        } else {
  	          if($.xhr.status == 200 || $.xhr.status == 201) {
  	            // HTTP 200, 201 (created)
  	            return('success');
  	          } else if($h.contains($.getOpt('permanentErrors'), $.xhr.status) || $.retries >= $.getOpt('maxChunkRetries')) {
  	            // HTTP 415/500/501, permanent error
  	            return('error');
  	          } else {
  	            // this should never happen, but we'll reset and queue a retry
  	            // a likely case for this would be 503 service unavailable
  	            $.abort();
  	            return('pending');
  	          }
  	        }
  	      };
  	      $.message = function(){
  	        return($.xhr ? $.xhr.responseText : '');
  	      };
  	      $.progress = function(relative){
  	        if(typeof(relative)==='undefined') relative = false;
  	        var factor = (relative ? ($.endByte-$.startByte)/$.fileObjSize : 1);
  	        if($.pendingRetry) return(0);
  	        if(!$.xhr || !$.xhr.status) factor*=.95;
  	        var s = $.status();
  	        switch(s){
  	        case 'success':
  	        case 'error':
  	          return(1*factor);
  	        case 'pending':
  	          return(0*factor);
  	        default:
  	          return($.loaded/($.endByte-$.startByte)*factor);
  	        }
  	      };
  	      return(this);
  	    }

  	    // QUEUE
  	    $.uploadNextChunk = function(){
  	      var found = false;

  	      // In some cases (such as videos) it's really handy to upload the first
  	      // and last chunk of a file quickly; this let's the server check the file's
  	      // metadata and determine if there's even a point in continuing.
  	      if ($.getOpt('prioritizeFirstAndLastChunk')) {
  	        $h.each($.files, function(file){
  	          if(file.chunks.length && file.chunks[0].status()=='pending' && file.chunks[0].preprocessState === 0) {
  	            file.chunks[0].send();
  	            found = true;
  	            return(false);
  	          }
  	          if(file.chunks.length>1 && file.chunks[file.chunks.length-1].status()=='pending' && file.chunks[file.chunks.length-1].preprocessState === 0) {
  	            file.chunks[file.chunks.length-1].send();
  	            found = true;
  	            return(false);
  	          }
  	        });
  	        if(found) return(true);
  	      }

  	      // Now, simply look for the next, best thing to upload
  	      $h.each($.files, function(file){
  	        if(file.isPaused()===false){
  	         $h.each(file.chunks, function(chunk){
  	           if(chunk.status()=='pending' && chunk.preprocessState === 0) {
  	             chunk.send();
  	             found = true;
  	             return(false);
  	           }
  	          });
  	        }
  	        if(found) return(false);
  	      });
  	      if(found) return(true);

  	      // The are no more outstanding chunks to upload, check is everything is done
  	      var outstanding = false;
  	      $h.each($.files, function(file){
  	        if(!file.isComplete()) {
  	          outstanding = true;
  	          return(false);
  	        }
  	      });
  	      if(!outstanding) {
  	        // All chunks have been uploaded, complete
  	        $.fire('complete');
  	      }
  	      return(false);
  	    };


  	    // PUBLIC METHODS FOR RESUMABLE.JS
  	    $.assignBrowse = function(domNodes, isDirectory){
  	      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];

  	      $h.each(domNodes, function(domNode) {
  	        var input;
  	        if(domNode.tagName==='INPUT' && domNode.type==='file'){
  	          input = domNode;
  	        } else {
  	          input = document.createElement('input');
  	          input.setAttribute('type', 'file');
  	          input.style.display = 'none';
  	          domNode.addEventListener('click', function(){
  	            input.style.opacity = 0;
  	            input.style.display='block';
  	            input.focus();
  	            input.click();
  	            input.style.display='none';
  	          }, false);
  	          domNode.appendChild(input);
  	        }
  	        var maxFiles = $.getOpt('maxFiles');
  	        if (typeof(maxFiles)==='undefined'||maxFiles!=1){
  	          input.setAttribute('multiple', 'multiple');
  	        } else {
  	          input.removeAttribute('multiple');
  	        }
  	        if(isDirectory){
  	          input.setAttribute('webkitdirectory', 'webkitdirectory');
  	        } else {
  	          input.removeAttribute('webkitdirectory');
  	        }
  	        var fileTypes = $.getOpt('fileType');
  	        if (typeof (fileTypes) !== 'undefined' && fileTypes.length >= 1) {
  	          input.setAttribute('accept', fileTypes.map(function (e) { return '.' + e }).join(','));
  	        }
  	        else {
  	          input.removeAttribute('accept');
  	        }
  	        // When new files are added, simply append them to the overall list
  	        input.addEventListener('change', function(e){
  	          appendFilesFromFileList(e.target.files,e);
  	          var clearInput = $.getOpt('clearInput');
  	          if (clearInput) {
  	            e.target.value = '';
  	          }
  	        }, false);
  	      });
  	    };
  	    $.assignDrop = function(domNodes){
  	      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];

  	      $h.each(domNodes, function(domNode) {
  	        domNode.addEventListener('dragover', preventDefault, false);
  	        domNode.addEventListener('dragenter', preventDefault, false);
  	        domNode.addEventListener('drop', onDrop, false);
  	      });
  	    };
  	    $.unAssignDrop = function(domNodes) {
  	      if (typeof(domNodes.length) == 'undefined') domNodes = [domNodes];

  	      $h.each(domNodes, function(domNode) {
  	        domNode.removeEventListener('dragover', preventDefault);
  	        domNode.removeEventListener('dragenter', preventDefault);
  	        domNode.removeEventListener('drop', onDrop);
  	      });
  	    };
  	    $.isUploading = function(){
  	      var uploading = false;
  	      $h.each($.files, function(file){
  	        if (file.isUploading()) {
  	          uploading = true;
  	          return(false);
  	        }
  	      });
  	      return(uploading);
  	    };
  	    $.upload = function(){
  	      // Make sure we don't start too many uploads at once
  	      if($.isUploading()) return;
  	      // Kick off the queue
  	      $.fire('uploadStart');
  	      for (var num=1; num<=$.getOpt('simultaneousUploads'); num++) {
  	        $.uploadNextChunk();
  	      }
  	    };
  	    $.pause = function(){
  	      // Resume all chunks currently being uploaded
  	      $h.each($.files, function(file){
  	        file.abort();
  	      });
  	      $.fire('pause');
  	    };
  	    $.cancel = function(){
  	      $.fire('beforeCancel');
  	      for(var i = $.files.length - 1; i >= 0; i--) {
  	        $.files[i].cancel();
  	      }
  	      $.fire('cancel');
  	    };
  	    $.progress = function(){
  	      var totalDone = 0;
  	      var totalSize = 0;
  	      // Resume all chunks currently being uploaded
  	      $h.each($.files, function(file){
  	        totalDone += file.progress()*file.size;
  	        totalSize += file.size;
  	      });
  	      return(totalSize>0 ? totalDone/totalSize : 0);
  	    };
  	    $.addFile = function(file, event){
  	      appendFilesFromFileList([file], event);
  	    };
  	    $.addFiles = function(files, event){
  	      appendFilesFromFileList(files, event);
  	    };
  	    $.removeFile = function(file){
  	      for(var i = $.files.length - 1; i >= 0; i--) {
  	        if($.files[i] === file) {
  	          $.files.splice(i, 1);
  	        }
  	      }
  	    };
  	    $.getFromUniqueIdentifier = function(uniqueIdentifier){
  	      var ret = false;
  	      $h.each($.files, function(f){
  	        if(f.uniqueIdentifier==uniqueIdentifier) ret = f;
  	      });
  	      return(ret);
  	    };
  	    $.getSize = function(){
  	      var totalSize = 0;
  	      $h.each($.files, function(file){
  	        totalSize += file.size;
  	      });
  	      return(totalSize);
  	    };
  	    $.handleDropEvent = function (e) {
  	      onDrop(e);
  	    };
  	    $.handleChangeEvent = function (e) {
  	      appendFilesFromFileList(e.target.files, e);
  	      e.target.value = '';
  	    };
  	    $.updateQuery = function(query){
  	        $.opts.query = query;
  	    };

  	    return(this);
  	  };


  	  // Node.js-style export for Node and Component
  	  {
  	    module.exports = Resumable;
  	  }

  	})(); 
  } (resumable));

  var resumableExports = resumable.exports;
  const Resumable = /*@__PURE__*/getDefaultExportFromCjs(resumableExports);

  function useResumableUploader(options, target) {
    const files = vueDemi.ref([]);
    const uploader = vueDemi.ref();
    const findFile = (file) => {
      return files.value.find((item) => item.file.uniqueIdentifier === file.uniqueIdentifier && item.status !== "canceled");
    };
    const cancelFile = (file) => {
      const _file = findFile(file);
      if (_file) {
        _file.status = "canceled";
        file.cancel();
      }
    };
    const createResumable = () => {
      const _uploader = new Resumable({
        maxChunkRetries: 1,
        testChunks: false,
        ...options
      });
      if (!_uploader.support) {
        throw new Error("Your browser doesn't support chunked uploads. Get a better browser.");
      }
      if (isFunction(target)) {
        uploader.value = target(_uploader);
      } else {
        const _browseEl = unrefElement(target.browse);
        if (_browseEl) {
          _uploader.assignBrowse(_browseEl, false);
        }
        if (isDef(target.drop)) {
          const _dropEl = unrefElement(target.drop);
          if (_dropEl) {
            _uploader.assignDrop(_dropEl);
          }
        }
        uploader.value = _uploader;
      }
      uploader.value.on("fileAdded", (file) => {
        file.hasUploaded = false;
        files.value.push({
          file,
          status: "uploading",
          progress: 0
        });
        uploader.value.upload();
      });
      uploader.value.on("fileSuccess", (file) => {
        findFile(file).status = "success";
      });
      uploader.value.on("fileError", (file) => {
        findFile(file).status = "error";
      });
      uploader.value.on("fileRetry", (file) => {
        findFile(file).status = "retrying";
      });
      uploader.value.on("fileProgress", (file) => {
        const localFile = findFile(file);
        const progress = file.progress(false);
        if (progress > localFile.progress) {
          localFile.progress = progress;
        }
      });
    };
    tryOnMounted(() => {
      createResumable();
    });
    return {
      files,
      uploader,
      findFile,
      cancelFile
    };
  }

  const loadingImg = "data:image/gif;base64,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";

  function makeImgFallbackDir(options = {}) {
    return {
      [`${vueDemi.isVue3 ? "beforeMount" : "bind"}`]: (el, binding) => {
        const { value } = binding;
        const defaultLoading = options?.loading || loadingImg;
        const defaultError = options?.error || options?.loading || loadingImg;
        const img = new Image();
        let loading = defaultLoading;
        let error = defaultError;
        const original = el.src;
        if (!value) {
          console.warn(
            `Vue Img Fallback Warning: Directive value is ${typeof value}. Now using default values.`
          );
        }
        if (isString(value)) {
          loading = error = value;
        } else if (isObject(value)) {
          loading = value.loading || defaultLoading;
          error = value.error || defaultError;
        }
        img.src = original;
        el.src = loading;
        img.onload = () => {
          el.src = original;
        };
        img.onerror = () => {
          el.src = error;
        };
      }
    };
  }
  const vImgFallback = makeImgFallbackDir();
  const ImgFallback = {
    install(app, options) {
      app.directive("img-fallback", makeImgFallbackDir(options));
    }
  };

  exports.FuseJS = FuseJS;
  exports.ImgFallback = ImgFallback;
  exports.Ripple = Ripple;
  exports.listenEvent = listenEvent;
  exports.refOf = refOf;
  exports.tryOnMounted = tryOnMounted;
  exports.tryOnScopeDispose = tryOnScopeDispose;
  exports.tryOnUnmounted = tryOnUnmounted;
  exports.unrefElement = unrefElement;
  exports.unrefOf = unrefOf;
  exports.useFuseJs = useFuseJs;
  exports.useLinkTag = useLinkTag;
  exports.useResumableUploader = useResumableUploader;
  exports.useRipple = useRipple;
  exports.useStyleTag = useStyleTag;
  exports.vImgFallback = vImgFallback;
  exports.vRipple = vRipple;

  return exports;

})({}, VueDemi);
//# sourceMappingURL=index.global.js.map
