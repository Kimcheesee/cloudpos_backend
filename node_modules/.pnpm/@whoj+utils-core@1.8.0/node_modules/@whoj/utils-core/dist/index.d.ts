/**
 * @license MIT
 * @module @whoj/utils-core@1.8.0
 * @copyright (c) 2023 Jonson B.
 */

import { Nullable, Arrayable, Func, DeepMerge, List, Dictionary } from '@whoj/utils-types';

/**
 * Convert `Arrayable<T>` to `Array<T>`
 *
 * @category Array
 */
declare function toArray<T>(array?: Nullable<Arrayable<T>>): Array<T>;
/**
 * Convert `Arrayable<T>` to `Array<T>` and flatten it
 *
 * @category Array
 */
declare function flattenArrayable<T>(array?: Nullable<Arrayable<T | Array<T>>>): Array<T>;
/**
 * Use rest arguments to merge arrays
 *
 * @category Array
 */
declare function mergeArrayable<T>(...args: Nullable<Arrayable<T>>[]): Array<T>;
type PartitionFilter<T> = (i: T, idx: number, arr: readonly T[]) => any;
/**
 * Divide an array into two parts by a filter function
 *
 * @category Array
 * @example const [odd, even] = partition([1, 2, 3, 4], i => i % 2 != 0)
 */
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>): [T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>): [T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>): [T[], T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>, f4: PartitionFilter<T>): [T[], T[], T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>, f4: PartitionFilter<T>, f5: PartitionFilter<T>): [T[], T[], T[], T[], T[], T[]];
declare function partition<T>(array: readonly T[], f1: PartitionFilter<T>, f2: PartitionFilter<T>, f3: PartitionFilter<T>, f4: PartitionFilter<T>, f5: PartitionFilter<T>, f6: PartitionFilter<T>): [T[], T[], T[], T[], T[], T[], T[]];
/**
 * Unique an Array
 *
 * @category Array
 */
declare function uniq<T>(array: readonly T[]): T[];
/**
 * Get last item
 *
 * @category Array
 */
declare function last(array: readonly []): undefined;
declare function last<T>(array: readonly T[]): T;
/**
 * Remove an item from Array
 *
 * @category Array
 */
declare function remove<T>(array: T[], value: T): boolean;
/**
 * Get nth item of Array. Negative for backward
 *
 * @category Array
 */
declare function at(array: readonly [], index: number): undefined;
declare function at<T>(array: readonly T[], index: number): T;
/**
 * Generate a range array of numbers. The `stop` is exclusive.
 *
 * @category Array
 */
declare function range(stop: number): number[];
declare function range(start: number, stop: number, step?: number): number[];
/**
 * Move element in an Array
 *
 * @category Array
 * @param arr
 * @param from
 * @param to
 */
declare function move<T>(arr: T[], from: number, to: number): T[];
/**
 * Clamp a number to the index ranage of an array
 *
 * @category Array
 */
declare function clampArrayRange(n: number, arr: readonly unknown[]): number;
/**
 * Get random items from an array
 *
 * @category Array
 */
declare function sample<T>(arr: T[], count: number): T[];
/**
 * Shuffle an array. This function mutates the array.
 *
 * @category Array
 */
declare function shuffle<T>(array: T[]): T[];
/**
 * Convert `Arrayable<T>` to `Array<T>` and flatten object's array by key
 *
 * Example:
 * const payload = [ { child: [{name: 'John Doe'}] }, { child: [ {age: 23} ] } ];
 * flattenDeepArray(payload, 'child');
 * Result: [{name: 'John Doe'}, {age: 23}]
 *
 * @param array
 * @type T extends object
 *
 * @param key
 * @type K extends keyof T
 */
declare function flattenDeepArray<T extends object, K extends keyof T>(array?: Nullable<Arrayable<T | Array<T>>>, key?: K): any;

/**
 * Assert
 *
 * @param condition -
 * @param message -
 *
 */
declare const assert: (condition: boolean, message: string) => asserts condition;
/**
 * Convert to String
 *
 * @param val -
 *
 * @returns - Converted String
 *
 */
declare const toString: (val: any) => any;
/**
 * Noop
 */
declare const noop: () => void;

type EventType = string | symbol;
type Handler<T = unknown> = (event: T) => void;
declare class Emitter<Events extends Record<EventType, unknown>> {
    private readonly _t;
    constructor();
    on<Key extends keyof Events>(event: Key, callback: Handler<Events[keyof Events]>, ctx?: {}): void;
    off<Key extends keyof Events>(event: Key, callback: Handler<Events[keyof Events]>): void;
    emit<Key extends keyof Events>(event: Key, args: Events[keyof Events]): boolean;
    once<Key extends keyof Events>(event: Key, callback: Handler<Events[keyof Events]>, ctx?: {}): void;
}

/**
 * Call every function in an array
 *
 * @category Function
 *
 * @param functions
 */
declare function batchInvoke(functions: Nullable<Func>[]): void;
/**
 * Call the function
 *
 * @category Function
 *
 * @param fn
 */
declare function invoke(fn: Func): void;
/**
 * Pass the value through the callback, and return the value
 *
 * @category Function
 *
 * @param val
 * @param callback
 *
 * @typeParam T
 * @typeParam D
 *
 * @example
 * ```
 * function createUser(name: string): User {
 *   return tap(new User, user => {
 *     user.name = name
 *   })
 * }
 * ```
 */
declare function tap<T, D = T>(val: T, callback: (val: T) => void | D): void | D;

/**
 * If the type of window is undefined, then we're on the server.
 */
declare const isServer: () => boolean;
/**
 * If the window object exists, then we're in the browser, otherwise we're in Node.
 */
declare const isClient: () => boolean;
/**
 * If we're on the server, return undefined, otherwise return the window object.
 */
declare const getWindow: () => Window | undefined;
/**
 * If document is defined, return document, otherwise return undefined.
 */
declare const getDocument: () => Document | undefined;
declare const _globalThis: typeof globalThis | Window;
type _Global = typeof _globalThis;
type _GlobalKey = `${keyof _Global}`;
/**
 * If we're on the server, return the global object, otherwise return the window object
 * @returns The global object.
 */
declare function getGlobal<T extends _GlobalKey>(prop?: T): T extends undefined ? _Global : _Global[T];
/**
 * @param options.scrollTarget - element that will be scrolled
 */
declare const scrollToElement: (element: HTMLElement, options?: {
    scrollTarget?: HTMLElement;
    verticalAlignment?: 'start' | 'end' | 'center' | 'any';
    smooth?: boolean;
}) => void;

/**
 * Type guard to filter out null-ish values
 *
 * @category Guards
 * @example array.filter(notNullish)
 */
declare function notNullish<T>(v: T | null | undefined): v is NonNullable<T>;
/**
 * Type guard to filter out null values
 *
 * @category Guards
 * @example array.filter(noNull)
 */
declare function noNull<T>(v: T | null): v is Exclude<T, null>;
/**
 * Type guard to filter out null-ish values
 *
 * @category Guards
 * @example array.filter(notUndefined)
 */
declare function notUndefined<T>(v: T): v is Exclude<T, undefined>;
/**
 * Type guard to filter out falsy values
 *
 * @category Guards
 * @example array.filter(isTruthy)
 */
declare function isTruthy<T>(v: T): v is NonNullable<T>;

// Type definitions for is-glob 4.0
// Project: https://github.com/micromatch/is-glob
// Definitions by: mrmlnc <https://github.com/mrmlnc>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

declare function isGlob(pattern?: string | string[] | null, options?: isGlob.Options): boolean;

declare namespace isGlob {
    interface Options {
        /**
         * When `false` the behavior is less strict in determining if a pattern is a glob. Meaning that some patterns
         * that would return false may return true. This is done so that matching libraries like micromatch
         * have a chance at determining if the pattern is a glob or not.
         */
        strict?: boolean | undefined;
    }
}

/**
 * @category Is Type
 *
 * @param val
 * @typeParam T
 *
 * @returns - Boolean
 *
 */
declare const isDef: <T = any>(val?: T) => val is T;
/**
 * Check if value is boolean
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isBoolean: (val: any) => val is boolean;
/**
 * Check if value is Function
 * @category Is Type
 *
 * @param val
 * @typeParam T
 * @returns - Boolean
 *
 */
declare const isFunction: <T extends Function>(val: any) => val is T;
/**
 * Check if value is Number
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isNumber: (val: any) => val is number;
/**
 * Check if value is Numberish
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isNumberish: (val: any) => val is number;
/**
 * Check if value is String
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isString: (val: unknown) => val is string;
/**
 * Check if value is Object
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isObject: <T extends object>(val: any) => val is T;
/**
 * Check if is Array
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isArray: <T = any>(val: any) => val is T[];
/**
 * Check if window defined
 * @category Is Type
 *
 * @param val
 * @returns - Boolean
 *
 */
declare const isWindow: (val: any) => boolean;
/**
 * Check if in Browser
 * @category Is Type
 *
 * @returns - Boolean
 *
 */
declare const isBrowser: boolean;
/**
 * Check if it has console
 * @category Is Type
 *
 * @returns - Boolean
 *
 */
declare const hasConsole: boolean;
/**
 * Check if it has glob pattern
 * @category Is Glob
 *
 * @returns - Boolean
 *
 */
declare const isGlobPattern: typeof isGlob;

/**
 * Clamp any number
 *
 * @param n - Number for clamp
 * @param min - Starting Number for clamp range
 * @param max - Ending Number for clamp range
 *
 * @returns The clamped value of given `n`
 */
declare function clamp(n: number, min: number, max: number): number;
/**
 * Sum any amount of number
 *
 * @param args - Numbers you need to sum
 *
 * @returns The summation of given `args`
 */
declare function sum(...args: number[] | number[][]): number;

/**
 * Map key/value pairs for an object, and construct a new one
 *
 *
 * @category Object
 *
 * Transform:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => [k.toString().toUpperCase(), v.toString()])
 * // { A: '1', B: '2' }
 * ```
 *
 * Swap key/value:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => [v, k])
 * // { 1: 'a', 2: 'b' }
 * ```
 *
 * Filter keys:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => k === 'a' ? undefined : [k, v])
 * // { b: 2 }
 * ```
 */
declare function objectMap<K extends string, V, NK = K, NV = V>(obj: Record<K, V>, fn: (key: K, value: V) => [NK, NV] | undefined): Record<K, V>;
/**
 * Type guard for any key, `k`.
 * Marks `k` as a key of `T` if `k` is in `obj`.
 *
 * @category Object
 *
 * @param obj object to query for key `k`
 * @param k key to check existence in `obj`
 *
 * @typeParam T
 */
declare function isKeyOf<T extends object>(obj: T, k: keyof any): k is keyof T;
/**
 * Strict typed `Object.keys`
 *
 * @category Object
 *
 * @param obj
 *
 * @typeParam T
 */
declare function objectKeys<T extends object>(obj: T): (keyof T)[];
/**
 * Strict typed `Object.entries`
 *
 * @category Object
 *
 * @param obj
 *
 * @typeParam T
 */
declare function objectEntries<T extends object>(obj: T): [keyof T, T[keyof T]][];
/**
 * Deep merge :P
 *
 * @category Object
 *
 * @param target
 * @param sources
 *
 * @typeParam T
 * @typeParam S
 */
declare function deepMerge<T extends object = object, S extends object = T>(target: T, ...sources: S[]): DeepMerge<T, S>;
/**
 * Create a new subset object by giving keys
 *
 * @category Object
 *
 * @param obj
 * @param keys
 * @param omitUndefined
 *
 * @typeParam O
 * @typeParam T
 */
declare function objectPick<O extends object, T extends keyof O>(obj: O, keys: T[], omitUndefined?: boolean): Pick<O, T>;
/**
 * Clear undefined fields from an object. It mutates the object
 *
 * @category Object
 *
 * @param obj
 * @typeParam T
 */
declare function clearUndefined<T extends object>(obj: T): T;
/**
 * Determines whether an object has a property with the specified name
 *
 * @category Object
 *
 * @param obj
 * @param key
 * @typeParam T
 */
declare function hasOwnProperty<T>(obj: T, key: PropertyKey): any;
/**
 *
 * @category Object
 *
 * @typeParam T
 * @param {Array} pairs
 */
declare function fromPairs<T>(pairs: List<[PropertyKey, T]>): Dictionary<T>;
/**
 *
 * @category Object
 *
 * @typeParam T
 *
 * @param {Dictionary} obj
 * @returns {Array}
 */
declare function toPairs<T>(obj: Dictionary<T>): [keyof Dictionary<T>, T][];

/**
 * @category Interface
 */
interface SingletonPromiseReturn<T> {
    (): Promise<T>;
    /**
     * Reset current staled promise.
     * Await it to have proper shutdown.
     */
    reset: () => Promise<void>;
}
/**
 * Create singleton promise function
 *
 * @category Promise
 */
declare function createSingletonPromise<T>(fn: () => Promise<T>): SingletonPromiseReturn<T>;
/**
 * Promised `setTimeout`
 *
 * @category Promise
 */
declare function sleep(ms: number, callback?: Func): Promise<void>;
/**
 * Create a promise lock
 *
 * @category Promise
 * @example
 * ```
 * const lock = createPromiseLock()
 *
 * lock.run(async () => {
 *   await doSomething()
 * })
 *
 * // in anther context:
 * await lock.wait() // it will wait all tasking finished
 * ```
 */
declare function createPromiseLock(): {
    run<T = void>(fn: () => Promise<T>): Promise<T>;
    wait(): Promise<void>;
    isWaiting(): boolean;
    clear(): void;
};
/**
 * Promise with `resolve` and `reject` methods of itself
 */
interface ControlledPromise<T = void> extends Promise<T> {
    resolve(value: T | PromiseLike<T>): void;
    reject(reason?: any): void;
}
/**
 * Return a Promise with `resolve` and `reject` methods
 *
 * @category Promise
 * @example
 * ```
 * const promise = createControlledPromise()
 *
 * await promise
 *
 * // in anther context:
 * promise.resolve(data)
 * ```
 */
declare function createControlledPromise<T>(): ControlledPromise<T>;
/**
 * Parallel Promise
 *
 * @category Promise
 */
declare function parallel<T, D = any>(tasks: T[], fn: (task: T) => Promise<D>): Promise<Awaited<D>[]>;
/**
 * Serial Promise
 *
 * @category Promise
 */
declare function serial<T>(tasks: T[], fn: (task: T, previous: any) => Promise<any>): Promise<any>;

/**
 * Replace backslash to slash
 *
 * @category String
 */
declare function slash(str: string): string;
/**
 * Replace backslash to slash
 *
 * @category String
 * @param {string} str
 *
 * @returns {string}
 */
declare const capitalize: Func<string>;
/**
 * Ensure prefix of a string
 *
 * @category String
 */
declare function ensurePrefix(prefix: string, str: string): string;
/**
 * Ensure suffix of a string
 *
 * @category String
 */
declare function ensureSuffix(suffix: string, str: string): string;
/**
 * Dead simple template engine, just like Python's `.format()`
 *
 * @category String
 * @example
 * ```
 * const result = template(
 *   'Hello {0}! My name is {1}.',
 *   'John',
 *   'B.'
 * ) // Hello John! My name is B..
 * ```
 */
declare function template(str: string, ...args: any[]): string;
/**
 * @category String
 * Divide a string into 2 parts by char(s)
 * You may define a position if string includes the separator multiple times
 * @param {string} str - The string to be divided.
 * @param {string} separator - The separator to use to divide the string.
 * @param {number} [position=1] - The position of the separator.
 *
 * It will make 2nd item for the return as empty string, if no separator found!
 * @returns string[]
 */
declare function divideStr(str: string, separator: string, position?: number): string[];

/**
 * Class for `setTimeout` with controls.
 * @internal
 *
 * @category Class
 */
declare class Timer {
    private timerId;
    private startedAt;
    private interval;
    /**
     * @readonly
     */
    readonly callback: CallableFunction;
    /**
     * @param cb - Callback for setTimeout
     * @param interval - delay (in millisecond)
     *
     * @beta
     */
    constructor(cb: (...args: unknown[]) => any, interval: number);
    /**
     * It stops the timer, then subtracts the time that has passed since the timer was started from the interval
     */
    pause(): void;
    /**
     * It resumes the timer by setting the startedAt property to the current time, and then setting the timerId property to
     * the result of calling setTimeout with the callback and interval properties
     */
    resume(): void;
    stop(): void;
}

/**
 * Timestamp value
 *
 * @category Time/Timer
 */
declare const timestamp: () => number;
/**
 * @param cb - Callback for setTimeout
 * @param interval - delay (in millisecond)
 *
 * @category Time/Timer
 */
declare function stoppableTimeOut(cb: (...args: unknown[]) => any, interval: number): Timer;

declare type Splitter = "-" | "_" | "/" | ".";
declare type FirstOfString<S extends string> = S extends `${infer F}${string}` ? F : never;
declare type RemoveFirstOfString<S extends string> = S extends `${string}${infer R}` ? R : never;
declare type IsUpper<S extends string> = S extends Uppercase<S> ? true : false;
declare type IsLower<S extends string> = S extends Lowercase<S> ? true : false;
declare type SameLetterCase<X extends string, Y extends string> = IsUpper<X> extends IsUpper<Y> ? true : IsLower<X> extends IsLower<Y> ? true : false;
declare type CapitalizedWords<T extends readonly string[], Accumulator extends string = ""> = T extends readonly [infer F extends string, ...infer R extends string[]] ? CapitalizedWords<R, `${Accumulator}${Capitalize<F>}`> : Accumulator;
declare type JoinLowercaseWords<T extends readonly string[], Joiner extends string, Accumulator extends string = ""> = T extends readonly [infer F extends string, ...infer R extends string[]] ? Accumulator extends "" ? JoinLowercaseWords<R, Joiner, `${Accumulator}${Lowercase<F>}`> : JoinLowercaseWords<R, Joiner, `${Accumulator}${Joiner}${Lowercase<F>}`> : Accumulator;
declare type LastOfArray<T extends any[]> = T extends [...any, infer R] ? R : never;
declare type RemoveLastOfArray<T extends any[]> = T extends [...infer F, any] ? F : never;
declare type SplitByCase<T, Separator extends string = Splitter, Accumulator extends unknown[] = []> = string extends Separator ? string[] : T extends `${infer F}${infer R}` ? [LastOfArray<Accumulator>] extends [never] ? SplitByCase<R, Separator, [F]> : LastOfArray<Accumulator> extends string ? R extends "" ? SplitByCase<R, Separator, [...RemoveLastOfArray<Accumulator>, `${LastOfArray<Accumulator>}${F}`]> : SameLetterCase<F, FirstOfString<R>> extends true ? F extends Separator ? FirstOfString<R> extends Separator ? SplitByCase<R, Separator, [...Accumulator, ""]> : IsUpper<FirstOfString<R>> extends true ? SplitByCase<RemoveFirstOfString<R>, Separator, [...Accumulator, FirstOfString<R>]> : SplitByCase<R, Separator, [...Accumulator, ""]> : SplitByCase<R, Separator, [...RemoveLastOfArray<Accumulator>, `${LastOfArray<Accumulator>}${F}`]> : IsLower<F> extends true ? SplitByCase<RemoveFirstOfString<R>, Separator, [...RemoveLastOfArray<Accumulator>, `${LastOfArray<Accumulator>}${F}`, FirstOfString<R>]> : SplitByCase<R, Separator, [...Accumulator, F]> : never : Accumulator extends [] ? T extends "" ? [] : string[] : Accumulator;
declare type PascalCase<T> = string extends T ? string : string[] extends T ? string : T extends string ? SplitByCase<T> extends readonly string[] ? CapitalizedWords<SplitByCase<T>> : never : T extends readonly string[] ? CapitalizedWords<T> : never;
declare type CamelCase<T> = string extends T ? string : string[] extends T ? string : Uncapitalize<PascalCase<T>>;
declare type JoinByCase<T, Joiner extends string> = string extends T ? string : string[] extends T ? string : T extends string ? SplitByCase<T> extends readonly string[] ? JoinLowercaseWords<SplitByCase<T>, Joiner> : never : T extends readonly string[] ? JoinLowercaseWords<T, Joiner> : never;
declare function pascalCase(): "";
declare function pascalCase<T extends string | readonly string[]>(string_: T): PascalCase<T>;
declare function camelCase(): "";
declare function camelCase<T extends string | readonly string[]>(string_: T): CamelCase<T>;
declare function kebabCase(): "";
declare function kebabCase<T extends string | readonly string[]>(string_: T): JoinByCase<T, "-">;
declare function kebabCase<T extends string | readonly string[], Joiner extends string>(string_: T, joiner: Joiner): JoinByCase<T, Joiner>;
declare function snakeCase(): "";
declare function snakeCase<T extends string | readonly string[]>(string_: T): JoinByCase<T, "_">;

// Type definitions for throttle-debounce 5.0
// Project: https://github.com/niksy/throttle-debounce
// Definitions by: Marek Buchar <https://github.com/czbuchi>, Frank Li <https://github.com/franklixuefei>, Thomas Oddsund <https://github.com/oddsund>, Seiya <https://github.com/seiyab>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped



interface CancelOptions {
    upcomingOnly?: boolean;
}

interface Cancel {
    cancel: (options?: CancelOptions) => void;
}

interface NoReturn<T extends (...args: any[]) => any> {
    (...args: Parameters<T>): void;
}

interface ThrottleOptions {
    noTrailing?: boolean;
    noLeading?: boolean;
    debounceMode?: boolean;
}

interface DebounceOptions {
    atBegin?: boolean;
}

type throttle<T extends (...args: any[]) => any> = NoReturn<T> & Cancel;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param delay
 * A zero-or-greater delay in milliseconds. For event callbacks, values around
 * 100 or 250 (or even higher) are most useful.
 *
 * @param callback
 * A function to be executed after delay milliseconds. The `this` context and
 * all arguments are passed through, as-is, to `callback` when the
 * throttled-function is executed.
 *
 * @param options
 * An object to configure options.
 *
 * @param options.noTrailing
 * Optional, defaults to false. If noTrailing is true, callback will only execute
 * every `delay` milliseconds while the throttled-function is being called. If
 * noTrailing is false or unspecified, callback will be executed one final time
 * after the last throttled-function call. (After the throttled-function has not
 * been called for `delay` milliseconds, the internal counter is reset)
 *
 * @param options.noLeading
 * Optional, defaults to false. If noLeading is false, the first throttled-function
 * call will execute callback immediately. If noLeading is true, the first the
 * callback execution will be skipped. It should be noted that callback will never
 * executed if both noLeading = true and noTrailing = true.
 *
 * @param options.debounceMode If `debounceMode` is true (at begin), schedule
 * `callback` to execute after `delay` ms. If `debounceMode` is false (at end),
 * schedule `callback` to execute after `delay` ms.
 *
 * @return
 * A new, throttled, function.
 */
declare function throttle<T extends (...args: any[]) => any>(
    delay: number,
    callback: T,
    options?: ThrottleOptions,
): throttle<T>;
type debounce<T extends (...args: any[]) => any> = NoReturn<T> & Cancel;

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param delay
 * A zero-or-greater delay in milliseconds. For event callbacks, values around
 * 100 or 250 (or even higher) are most useful.
 *
 * @param callback
 * A function to be executed after delay milliseconds. The `this` context and
 * all arguments are passed through, as-is, to `callback` when the
 * debounced-function is executed.
 *
 * @param options
 * An object to configure options.
 *
 * @param options.atBegin
 * If atBegin is false or unspecified, callback will only be executed `delay`
 * milliseconds after the last debounced-function call. If atBegin is true,
 * callback will be executed only at the first debounced-function call. (After
 * the throttled-function has not been called for `delay` milliseconds, the
 * internal counter is reset).
 *
 * @return
 * A new, debounced function.
 */
declare function debounce<T extends (...args: any[]) => any>(
    delay: number,
    callback: T,
    options?: DebounceOptions,
): debounce<T>;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

type StringDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

/**
Get keys of the given type as strings.

Number keys are converted to strings.

Use-cases:
- Get string keys from a type which may have number keys.
- Makes it possible to index using strings retrieved from template types.

@example
```
import type {StringKeyOf} from 'type-fest';

type Foo = {
	1: number,
	stringKey: string,
};

type StringKeysOfFoo = StringKeyOf<Foo>;
//=> '1' | 'stringKey'
```

@category Object
*/
type StringKeyOf<BaseType> = `${Extract<keyof BaseType, string | number>}`;

/**
Represents an array of strings split using a given character or character set.

Use-case: Defining the return type of a method like `String.prototype.split`.

@example
```
import type {Split} from 'type-fest';

declare function split<S extends string, D extends string>(string: S, separator: D): Split<S, D>;

type Item = 'foo' | 'bar' | 'baz' | 'waldo';
const items = 'foo,bar,baz,waldo';
let array: Item[];

array = split(items, ',');
```

@category String
@category Template literal
*/
type Split<
	S extends string,
	Delimiter extends string,
> = S extends `${infer Head}${Delimiter}${infer Tail}`
	? [Head, ...Split<Tail, Delimiter>]
	: S extends Delimiter
		? []
		: [S];

type GetOptions = {
	/**
	Include `undefined` in the return type when accessing properties.

	Setting this to `false` is not recommended.

	@default true
	*/
	strict?: boolean;
};

/**
Like the `Get` type but receives an array of strings as a path parameter.
*/
type GetWithPath<BaseType, Keys extends readonly string[], Options extends GetOptions = {}> =
	Keys extends []
		? BaseType
		: Keys extends readonly [infer Head, ...infer Tail]
			? GetWithPath<
			PropertyOf<BaseType, Extract<Head, string>, Options>,
			Extract<Tail, string[]>,
			Options
			>
			: never;

/**
Adds `undefined` to `Type` if `strict` is enabled.
*/
type Strictify<Type, Options extends GetOptions> =
	Options['strict'] extends false ? Type : (Type | undefined);

/**
If `Options['strict']` is `true`, includes `undefined` in the returned type when accessing properties on `Record<string, any>`.

Known limitations:
- Does not include `undefined` in the type on object types with an index signature (for example, `{a: string; [key: string]: string}`).
*/
type StrictPropertyOf<BaseType, Key extends keyof BaseType, Options extends GetOptions> =
	Record<string, any> extends BaseType
		? string extends keyof BaseType
			? Strictify<BaseType[Key], Options> // Record<string, any>
			: BaseType[Key] // Record<'a' | 'b', any> (Records with a string union as keys have required properties)
		: BaseType[Key];

/**
Splits a dot-prop style path into a tuple comprised of the properties in the path. Handles square-bracket notation.

@example
```
ToPath<'foo.bar.baz'>
//=> ['foo', 'bar', 'baz']

ToPath<'foo[0].bar.baz'>
//=> ['foo', '0', 'bar', 'baz']
```
*/
type ToPath<S extends string> = Split<FixPathSquareBrackets<S>, '.'>;

/**
Replaces square-bracketed dot notation with dots, for example, `foo[0].bar` -> `foo.0.bar`.
*/
type FixPathSquareBrackets<Path extends string> =
	Path extends `[${infer Head}]${infer Tail}`
		? Tail extends `[${string}`
			? `${Head}.${FixPathSquareBrackets<Tail>}`
			: `${Head}${FixPathSquareBrackets<Tail>}`
		: Path extends `${infer Head}[${infer Middle}]${infer Tail}`
			? `${Head}.${FixPathSquareBrackets<`[${Middle}]${Tail}`>}`
			: Path;

/**
Returns true if `LongString` is made up out of `Substring` repeated 0 or more times.

@example
```
ConsistsOnlyOf<'aaa', 'a'> //=> true
ConsistsOnlyOf<'ababab', 'ab'> //=> true
ConsistsOnlyOf<'aBa', 'a'> //=> false
ConsistsOnlyOf<'', 'a'> //=> true
```
*/
type ConsistsOnlyOf<LongString extends string, Substring extends string> =
	LongString extends ''
		? true
		: LongString extends `${Substring}${infer Tail}`
			? ConsistsOnlyOf<Tail, Substring>
			: false;

/**
Convert a type which may have number keys to one with string keys, making it possible to index using strings retrieved from template types.

@example
```
type WithNumbers = {foo: string; 0: boolean};
type WithStrings = WithStringKeys<WithNumbers>;

type WithNumbersKeys = keyof WithNumbers;
//=> 'foo' | 0
type WithStringsKeys = keyof WithStrings;
//=> 'foo' | '0'
```
*/
type WithStringKeys<BaseType> = {
	[Key in StringKeyOf<BaseType>]: UncheckedIndex<BaseType, Key>
};

/**
Perform a `T[U]` operation if `T` supports indexing.
*/
type UncheckedIndex<T, U extends string | number> = [T] extends [Record<string | number, any>] ? T[U] : never;

/**
Get a property of an object or array. Works when indexing arrays using number-literal-strings, for example, `PropertyOf<number[], '0'> = number`, and when indexing objects with number keys.

Note:
- Returns `unknown` if `Key` is not a property of `BaseType`, since TypeScript uses structural typing, and it cannot be guaranteed that extra properties unknown to the type system will exist at runtime.
- Returns `undefined` from nullish values, to match the behaviour of most deep-key libraries like `lodash`, `dot-prop`, etc.
*/
type PropertyOf<BaseType, Key extends string, Options extends GetOptions = {}> =
	BaseType extends null | undefined
		? undefined
		: Key extends keyof BaseType
			? StrictPropertyOf<BaseType, Key, Options>
			: BaseType extends [] | [unknown, ...unknown[]]
				? unknown // It's a tuple, but `Key` did not extend `keyof BaseType`. So the index is out of bounds.
				: BaseType extends {
					[n: number]: infer Item;
					length: number; // Note: This is needed to avoid being too lax with records types using number keys like `{0: string; 1: boolean}`.
				}
					? (
						ConsistsOnlyOf<Key, StringDigit> extends true
							? Strictify<Item, Options>
							: unknown
					)
					: Key extends keyof WithStringKeys<BaseType>
						? StrictPropertyOf<WithStringKeys<BaseType>, Key, Options>
						: unknown;

// This works by first splitting the path based on `.` and `[...]` characters into a tuple of string keys. Then it recursively uses the head key to get the next property of the current object, until there are no keys left. Number keys extract the item type from arrays, or are converted to strings to extract types from tuples and dictionaries with number keys.
/**
Get a deeply-nested property from an object using a key path, like Lodash's `.get()` function.

Use-case: Retrieve a property from deep inside an API response or some other complex object.

@example
```
import type {Get} from 'type-fest';
import * as lodash from 'lodash';

const get = <BaseType, Path extends string | readonly string[]>(object: BaseType, path: Path): Get<BaseType, Path> =>
	lodash.get(object, path);

interface ApiResponse {
	hits: {
		hits: Array<{
			_id: string
			_source: {
				name: Array<{
					given: string[]
					family: string
				}>
				birthDate: string
			}
		}>
	}
}

const getName = (apiResponse: ApiResponse) =>
	get(apiResponse, 'hits.hits[0]._source.name');
	//=> Array<{given: string[]; family: string}> | undefined

// Path also supports a readonly array of strings
const getNameWithPathArray = (apiResponse: ApiResponse) =>
	get(apiResponse, ['hits','hits', '0', '_source', 'name'] as const);
	//=> Array<{given: string[]; family: string}> | undefined

// Non-strict mode:
Get<string[], '3', {strict: false}> //=> string
Get<Record<string, string>, 'foo', {strict: true}> // => string
```

@category Object
@category Array
@category Template literal
*/
type Get<BaseType, Path extends string | readonly string[], Options extends GetOptions = {}> =
	GetWithPath<BaseType, Path extends string ? ToPath<Path> : Path, Options>;

/**
Get the value of the property at the given path.

@param object - Object or array to get the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.
@param defaultValue - Default value.

@example
```
import {getProperty} from 'dot-prop';

getProperty({foo: {bar: 'unicorn'}}, 'foo.bar');
//=> 'unicorn'

getProperty({foo: {bar: 'a'}}, 'foo.notDefined.deep');
//=> undefined

getProperty({foo: {bar: 'a'}}, 'foo.notDefined.deep', 'default value');
//=> 'default value'

getProperty({foo: {'dot.dot': 'unicorn'}}, 'foo.dot\\.dot');
//=> 'unicorn'

getProperty({foo: [{bar: 'unicorn'}]}, 'foo[0].bar');
//=> 'unicorn'
```
*/
declare function getProperty<ObjectType, PathType extends string, DefaultValue = undefined>(
	object: ObjectType,
	path: PathType,
	defaultValue?: DefaultValue
): ObjectType extends Record<string, unknown> | unknown[] ? (unknown extends Get<ObjectType, PathType> ? DefaultValue : Get<ObjectType, PathType>) : undefined;

/**
Set the property at the given path to the given value.

@param object - Object or array to set the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.
@param value - Value to set at `path`.
@returns The object.

@example
```
import {setProperty} from 'dot-prop';

const object = {foo: {bar: 'a'}};
setProperty(object, 'foo.bar', 'b');
console.log(object);
//=> {foo: {bar: 'b'}}

const foo = setProperty({}, 'foo.bar', 'c');
console.log(foo);
//=> {foo: {bar: 'c'}}

setProperty(object, 'foo.baz', 'x');
console.log(object);
//=> {foo: {bar: 'b', baz: 'x'}}

setProperty(object, 'foo.biz[0]', 'a');
console.log(object);
//=> {foo: {bar: 'b', baz: 'x', biz: ['a']}}
```
*/
declare function setProperty<ObjectType extends Record<string, any>>(
	object: ObjectType,
	path: string,
	value: unknown
): ObjectType;

/**
Check whether the property at the given path exists.

@param object - Object or array to test the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.

@example
```
import {hasProperty} from 'dot-prop';

hasProperty({foo: {bar: 'unicorn'}}, 'foo.bar');
//=> true
```
*/
declare function hasProperty(object: Record<string, any> | undefined, path: string): boolean;

/**
Delete the property at the given path.

@param object - Object or array to delete the `path` value.
@param path - Path of the property in the object, using `.` to separate each nested key. Use `\\.` if you have a `.` in the key.
@returns A boolean of whether the property existed before being deleted.

@example
```
import {deleteProperty} from 'dot-prop';

const object = {foo: {bar: 'a'}};
deleteProperty(object, 'foo.bar');
console.log(object);
//=> {foo: {}}

object.foo.bar = {x: 'y', y: 'x'};
deleteProperty(object, 'foo.bar.x');
console.log(object);
//=> {foo: {bar: {y: 'x'}}}
```
*/
declare function deleteProperty(object: Record<string, any>, path: string): boolean;

interface Options {
    splitRegexp?: RegExp | RegExp[];
    stripRegexp?: RegExp | RegExp[];
    delimiter?: string;
    transform?: (part: string, index: number, parts: string[]) => string;
}

declare function dotCase(input: string, options?: Options): string;

declare function pathCase(input: string, options?: Options): string;

declare function paramCase(input: string, options?: Options): string;

/**
 * @category String
 */
declare function changeCase(str: string, to: 'camel' | 'snake' | 'kebab' | 'pascal'): string;

export { type ConsistsOnlyOf, type IsUpper, type IsLower, type CapitalizedWords, type PascalCase, type CamelCase, type StringDigit, type ControlledPromise, Emitter, type EventType, type Handler, type PartitionFilter, type SingletonPromiseReturn, assert, at, batchInvoke, camelCase, capitalize, changeCase, clamp, clampArrayRange, clearUndefined, createControlledPromise, createPromiseLock, createSingletonPromise, debounce, deepMerge, deleteProperty as deleteObjProp, deleteProperty, divideStr, dotCase, ensurePrefix, ensureSuffix, flattenArrayable, flattenDeepArray, fromPairs, getDocument, getGlobal, getProperty as getObjProp, getProperty, getWindow, hasConsole, hasProperty as hasObjProp, hasOwnProperty, hasProperty, invoke, isArray, isBoolean, isBrowser, isClient, isDef, isFunction, isGlobPattern, isKeyOf, isNumber, isNumberish, isObject, isServer, isString, isTruthy, isWindow, kebabCase, last, mergeArrayable, move, noNull, noop, notNullish, notUndefined, objectEntries, objectKeys, objectMap, objectPick, parallel, paramCase, partition, pascalCase, pathCase, range, remove, sample, scrollToElement, serial, setProperty as setObjProp, setProperty, shuffle, slash, sleep, snakeCase, stoppableTimeOut, sum, tap, template, throttle, timestamp, toArray, toPairs, toString, uniq };
//# sourceMappingURL=index.d.ts.map
