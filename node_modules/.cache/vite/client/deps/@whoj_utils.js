import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/.pnpm/resumablejs@1.1.0/node_modules/resumablejs/resumable.js
var require_resumable = __commonJS({
  "node_modules/.pnpm/resumablejs@1.1.0/node_modules/resumablejs/resumable.js"(exports, module) {
    (function() {
      "use strict";
      var Resumable2 = function(opts) {
        if (!(this instanceof Resumable2)) {
          return new Resumable2(opts);
        }
        this.version = 1;
        this.support = typeof File !== "undefined" && typeof Blob !== "undefined" && typeof FileList !== "undefined" && (!!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice || !!Blob.prototype.slice || false);
        if (!this.support)
          return false;
        var $ = this;
        $.files = [];
        $.defaults = {
          chunkSize: 1 * 1024 * 1024,
          forceChunkSize: false,
          simultaneousUploads: 3,
          fileParameterName: "file",
          chunkNumberParameterName: "resumableChunkNumber",
          chunkSizeParameterName: "resumableChunkSize",
          currentChunkSizeParameterName: "resumableCurrentChunkSize",
          totalSizeParameterName: "resumableTotalSize",
          typeParameterName: "resumableType",
          identifierParameterName: "resumableIdentifier",
          fileNameParameterName: "resumableFilename",
          relativePathParameterName: "resumableRelativePath",
          totalChunksParameterName: "resumableTotalChunks",
          throttleProgressCallbacks: 0.5,
          query: {},
          headers: {},
          preprocess: null,
          method: "multipart",
          uploadMethod: "POST",
          testMethod: "GET",
          prioritizeFirstAndLastChunk: false,
          target: "/",
          testTarget: null,
          parameterNamespace: "",
          testChunks: true,
          generateUniqueIdentifier: null,
          getTarget: null,
          maxChunkRetries: 100,
          chunkRetryInterval: void 0,
          permanentErrors: [400, 404, 415, 500, 501],
          maxFiles: void 0,
          withCredentials: false,
          xhrTimeout: 0,
          clearInput: true,
          chunkFormat: "blob",
          setChunkTypeFromFile: false,
          maxFilesErrorCallback: function(files, errorCount) {
            var maxFiles = $.getOpt("maxFiles");
            alert("Please upload no more than " + maxFiles + " file" + (maxFiles === 1 ? "" : "s") + " at a time.");
          },
          minFileSize: 1,
          minFileSizeErrorCallback: function(file, errorCount) {
            alert(file.fileName || file.name + " is too small, please upload files larger than " + $h.formatSize($.getOpt("minFileSize")) + ".");
          },
          maxFileSize: void 0,
          maxFileSizeErrorCallback: function(file, errorCount) {
            alert(file.fileName || file.name + " is too large, please upload files less than " + $h.formatSize($.getOpt("maxFileSize")) + ".");
          },
          fileType: [],
          fileTypeErrorCallback: function(file, errorCount) {
            alert(file.fileName || file.name + " has type not allowed, please upload files of type " + $.getOpt("fileType") + ".");
          }
        };
        $.opts = opts || {};
        $.getOpt = function(o) {
          var $opt = this;
          if (o instanceof Array) {
            var options = {};
            $h.each(o, function(option) {
              options[option] = $opt.getOpt(option);
            });
            return options;
          }
          if ($opt instanceof ResumableChunk) {
            if (typeof $opt.opts[o] !== "undefined") {
              return $opt.opts[o];
            } else {
              $opt = $opt.fileObj;
            }
          }
          if ($opt instanceof ResumableFile) {
            if (typeof $opt.opts[o] !== "undefined") {
              return $opt.opts[o];
            } else {
              $opt = $opt.resumableObj;
            }
          }
          if ($opt instanceof Resumable2) {
            if (typeof $opt.opts[o] !== "undefined") {
              return $opt.opts[o];
            } else {
              return $opt.defaults[o];
            }
          }
        };
        $.events = [];
        $.on = function(event, callback) {
          $.events.push(event.toLowerCase(), callback);
        };
        $.fire = function() {
          var args = [];
          for (var i = 0; i < arguments.length; i++)
            args.push(arguments[i]);
          var event = args[0].toLowerCase();
          for (var i = 0; i <= $.events.length; i += 2) {
            if ($.events[i] == event)
              $.events[i + 1].apply($, args.slice(1));
            if ($.events[i] == "catchall")
              $.events[i + 1].apply(null, args);
          }
          if (event == "fileerror")
            $.fire("error", args[2], args[1]);
          if (event == "fileprogress")
            $.fire("progress");
        };
        var $h = {
          stopEvent: function(e) {
            e.stopPropagation();
            e.preventDefault();
          },
          each: function(o, callback) {
            if (typeof o.length !== "undefined") {
              for (var i = 0; i < o.length; i++) {
                if (callback(o[i]) === false)
                  return;
              }
            } else {
              for (i in o) {
                if (callback(i, o[i]) === false)
                  return;
              }
            }
          },
          generateUniqueIdentifier: function(file, event) {
            var custom = $.getOpt("generateUniqueIdentifier");
            if (typeof custom === "function") {
              return custom(file, event);
            }
            var relativePath = file.webkitRelativePath || file.fileName || file.name;
            var size = file.size;
            return size + "-" + relativePath.replace(/[^0-9a-zA-Z_-]/img, "");
          },
          contains: function(array, test) {
            var result = false;
            $h.each(array, function(value) {
              if (value == test) {
                result = true;
                return false;
              }
              return true;
            });
            return result;
          },
          formatSize: function(size) {
            if (size < 1024) {
              return size + " bytes";
            } else if (size < 1024 * 1024) {
              return (size / 1024).toFixed(0) + " KB";
            } else if (size < 1024 * 1024 * 1024) {
              return (size / 1024 / 1024).toFixed(1) + " MB";
            } else {
              return (size / 1024 / 1024 / 1024).toFixed(1) + " GB";
            }
          },
          getTarget: function(request, params) {
            var target = $.getOpt("target");
            if (request === "test" && $.getOpt("testTarget")) {
              target = $.getOpt("testTarget") === "/" ? $.getOpt("target") : $.getOpt("testTarget");
            }
            if (typeof target === "function") {
              return target(params);
            }
            var separator = target.indexOf("?") < 0 ? "?" : "&";
            var joinedParams = params.join("&");
            return target + separator + joinedParams;
          }
        };
        var onDrop = function(event) {
          $h.stopEvent(event);
          if (event.dataTransfer && event.dataTransfer.items) {
            loadFiles(event.dataTransfer.items, event);
          } else if (event.dataTransfer && event.dataTransfer.files) {
            loadFiles(event.dataTransfer.files, event);
          }
        };
        var preventDefault = function(e) {
          e.preventDefault();
        };
        function processItem(item, path, items, cb) {
          var entry;
          if (item.isFile) {
            return item.file(function(file) {
              file.relativePath = path + file.name;
              items.push(file);
              cb();
            });
          } else if (item.isDirectory) {
            entry = item;
          } else if (item instanceof File) {
            items.push(item);
          }
          if ("function" === typeof item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
          }
          if (entry && entry.isDirectory) {
            return processDirectory(entry, path + entry.name + "/", items, cb);
          }
          if ("function" === typeof item.getAsFile) {
            item = item.getAsFile();
            if (item instanceof File) {
              item.relativePath = path + item.name;
              items.push(item);
            }
          }
          cb();
        }
        function processCallbacks(items, cb) {
          if (!items || items.length === 0) {
            return cb();
          }
          items[0](function() {
            processCallbacks(items.slice(1), cb);
          });
        }
        function processDirectory(directory, path, items, cb) {
          var dirReader = directory.createReader();
          dirReader.readEntries(function(entries) {
            if (!entries.length) {
              return cb();
            }
            processCallbacks(
              entries.map(function(entry) {
                return processItem.bind(null, entry, path, items);
              }),
              cb
            );
          });
        }
        function loadFiles(items, event) {
          if (!items.length) {
            return;
          }
          $.fire("beforeAdd");
          var files = [];
          processCallbacks(
            Array.prototype.map.call(items, function(item) {
              return processItem.bind(null, item, "", files);
            }),
            function() {
              if (files.length) {
                appendFilesFromFileList(files, event);
              }
            }
          );
        }
        ;
        var appendFilesFromFileList = function(fileList, event) {
          var errorCount = 0;
          var o = $.getOpt(["maxFiles", "minFileSize", "maxFileSize", "maxFilesErrorCallback", "minFileSizeErrorCallback", "maxFileSizeErrorCallback", "fileType", "fileTypeErrorCallback"]);
          if (typeof o.maxFiles !== "undefined" && o.maxFiles < fileList.length + $.files.length) {
            if (o.maxFiles === 1 && $.files.length === 1 && fileList.length === 1) {
              $.removeFile($.files[0]);
            } else {
              o.maxFilesErrorCallback(fileList, errorCount++);
              return false;
            }
          }
          var files = [], filesSkipped = [], remaining = fileList.length;
          var decreaseReamining = function() {
            if (!--remaining) {
              if (!files.length && !filesSkipped.length) {
                return;
              }
              window.setTimeout(function() {
                $.fire("filesAdded", files, filesSkipped);
              }, 0);
            }
          };
          $h.each(fileList, function(file) {
            var fileName = file.name;
            if (o.fileType.length > 0) {
              var fileTypeFound = false;
              for (var index in o.fileType) {
                var extension = "." + o.fileType[index];
                if (fileName.toLowerCase().indexOf(extension.toLowerCase(), fileName.length - extension.length) !== -1) {
                  fileTypeFound = true;
                  break;
                }
              }
              if (!fileTypeFound) {
                o.fileTypeErrorCallback(file, errorCount++);
                return false;
              }
            }
            if (typeof o.minFileSize !== "undefined" && file.size < o.minFileSize) {
              o.minFileSizeErrorCallback(file, errorCount++);
              return false;
            }
            if (typeof o.maxFileSize !== "undefined" && file.size > o.maxFileSize) {
              o.maxFileSizeErrorCallback(file, errorCount++);
              return false;
            }
            function addFile(uniqueIdentifier2) {
              if (!$.getFromUniqueIdentifier(uniqueIdentifier2)) {
                (function() {
                  file.uniqueIdentifier = uniqueIdentifier2;
                  var f = new ResumableFile($, file, uniqueIdentifier2);
                  $.files.push(f);
                  files.push(f);
                  f.container = typeof event != "undefined" ? event.srcElement : null;
                  window.setTimeout(function() {
                    $.fire("fileAdded", f, event);
                  }, 0);
                })();
              } else {
                filesSkipped.push(file);
              }
              ;
              decreaseReamining();
            }
            var uniqueIdentifier = $h.generateUniqueIdentifier(file, event);
            if (uniqueIdentifier && typeof uniqueIdentifier.then === "function") {
              uniqueIdentifier.then(
                function(uniqueIdentifier2) {
                  addFile(uniqueIdentifier2);
                },
                function() {
                  decreaseReamining();
                }
              );
            } else {
              addFile(uniqueIdentifier);
            }
          });
        };
        function ResumableFile(resumableObj, file, uniqueIdentifier) {
          var $2 = this;
          $2.opts = {};
          $2.getOpt = resumableObj.getOpt;
          $2._prevProgress = 0;
          $2.resumableObj = resumableObj;
          $2.file = file;
          $2.fileName = file.fileName || file.name;
          $2.size = file.size;
          $2.relativePath = file.relativePath || file.webkitRelativePath || $2.fileName;
          $2.uniqueIdentifier = uniqueIdentifier;
          $2._pause = false;
          $2.container = "";
          var _error = uniqueIdentifier !== void 0;
          var chunkEvent = function(event, message) {
            switch (event) {
              case "progress":
                $2.resumableObj.fire("fileProgress", $2, message);
                break;
              case "error":
                $2.abort();
                _error = true;
                $2.chunks = [];
                $2.resumableObj.fire("fileError", $2, message);
                break;
              case "success":
                if (_error)
                  return;
                $2.resumableObj.fire("fileProgress", $2);
                if ($2.isComplete()) {
                  $2.resumableObj.fire("fileSuccess", $2, message);
                }
                break;
              case "retry":
                $2.resumableObj.fire("fileRetry", $2);
                break;
            }
          };
          $2.chunks = [];
          $2.abort = function() {
            var abortCount = 0;
            $h.each($2.chunks, function(c) {
              if (c.status() == "uploading") {
                c.abort();
                abortCount++;
              }
            });
            if (abortCount > 0)
              $2.resumableObj.fire("fileProgress", $2);
          };
          $2.cancel = function() {
            var _chunks = $2.chunks;
            $2.chunks = [];
            $h.each(_chunks, function(c) {
              if (c.status() == "uploading") {
                c.abort();
                $2.resumableObj.uploadNextChunk();
              }
            });
            $2.resumableObj.removeFile($2);
            $2.resumableObj.fire("fileProgress", $2);
          };
          $2.retry = function() {
            $2.bootstrap();
            var firedRetry = false;
            $2.resumableObj.on("chunkingComplete", function() {
              if (!firedRetry)
                $2.resumableObj.upload();
              firedRetry = true;
            });
          };
          $2.bootstrap = function() {
            $2.abort();
            _error = false;
            $2.chunks = [];
            $2._prevProgress = 0;
            var round = $2.getOpt("forceChunkSize") ? Math.ceil : Math.floor;
            var maxOffset = Math.max(round($2.file.size / $2.getOpt("chunkSize")), 1);
            for (var offset = 0; offset < maxOffset; offset++) {
              (function(offset2) {
                window.setTimeout(function() {
                  $2.chunks.push(new ResumableChunk($2.resumableObj, $2, offset2, chunkEvent));
                  $2.resumableObj.fire("chunkingProgress", $2, offset2 / maxOffset);
                }, 0);
              })(offset);
            }
            window.setTimeout(function() {
              $2.resumableObj.fire("chunkingComplete", $2);
            }, 0);
          };
          $2.progress = function() {
            if (_error)
              return 1;
            var ret = 0;
            var error = false;
            $h.each($2.chunks, function(c) {
              if (c.status() == "error")
                error = true;
              ret += c.progress(true);
            });
            ret = error ? 1 : ret > 0.99999 ? 1 : ret;
            ret = Math.max($2._prevProgress, ret);
            $2._prevProgress = ret;
            return ret;
          };
          $2.isUploading = function() {
            var uploading = false;
            $h.each($2.chunks, function(chunk) {
              if (chunk.status() == "uploading") {
                uploading = true;
                return false;
              }
            });
            return uploading;
          };
          $2.isComplete = function() {
            var outstanding = false;
            $h.each($2.chunks, function(chunk) {
              var status = chunk.status();
              if (status == "pending" || status == "uploading" || chunk.preprocessState === 1) {
                outstanding = true;
                return false;
              }
            });
            return !outstanding;
          };
          $2.pause = function(pause) {
            if (typeof pause === "undefined") {
              $2._pause = $2._pause ? false : true;
            } else {
              $2._pause = pause;
            }
          };
          $2.isPaused = function() {
            return $2._pause;
          };
          $2.resumableObj.fire("chunkingStart", $2);
          $2.bootstrap();
          return this;
        }
        function ResumableChunk(resumableObj, fileObj, offset, callback) {
          var $2 = this;
          $2.opts = {};
          $2.getOpt = resumableObj.getOpt;
          $2.resumableObj = resumableObj;
          $2.fileObj = fileObj;
          $2.fileObjSize = fileObj.size;
          $2.fileObjType = fileObj.file.type;
          $2.offset = offset;
          $2.callback = callback;
          $2.lastProgressCallback = /* @__PURE__ */ new Date();
          $2.tested = false;
          $2.retries = 0;
          $2.pendingRetry = false;
          $2.preprocessState = 0;
          var chunkSize = $2.getOpt("chunkSize");
          $2.loaded = 0;
          $2.startByte = $2.offset * chunkSize;
          $2.endByte = Math.min($2.fileObjSize, ($2.offset + 1) * chunkSize);
          if ($2.fileObjSize - $2.endByte < chunkSize && !$2.getOpt("forceChunkSize")) {
            $2.endByte = $2.fileObjSize;
          }
          $2.xhr = null;
          $2.test = function() {
            $2.xhr = new XMLHttpRequest();
            var testHandler = function(e) {
              $2.tested = true;
              var status = $2.status();
              if (status == "success") {
                $2.callback(status, $2.message());
                $2.resumableObj.uploadNextChunk();
              } else {
                $2.send();
              }
            };
            $2.xhr.addEventListener("load", testHandler, false);
            $2.xhr.addEventListener("error", testHandler, false);
            $2.xhr.addEventListener("timeout", testHandler, false);
            var params = [];
            var parameterNamespace = $2.getOpt("parameterNamespace");
            var customQuery = $2.getOpt("query");
            if (typeof customQuery == "function")
              customQuery = customQuery($2.fileObj, $2);
            $h.each(customQuery, function(k, v) {
              params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join("="));
            });
            params = params.concat(
              [
                // define key/value pairs for additional parameters
                ["chunkNumberParameterName", $2.offset + 1],
                ["chunkSizeParameterName", $2.getOpt("chunkSize")],
                ["currentChunkSizeParameterName", $2.endByte - $2.startByte],
                ["totalSizeParameterName", $2.fileObjSize],
                ["typeParameterName", $2.fileObjType],
                ["identifierParameterName", $2.fileObj.uniqueIdentifier],
                ["fileNameParameterName", $2.fileObj.fileName],
                ["relativePathParameterName", $2.fileObj.relativePath],
                ["totalChunksParameterName", $2.fileObj.chunks.length]
              ].filter(function(pair) {
                return $2.getOpt(pair[0]);
              }).map(function(pair) {
                return [
                  parameterNamespace + $2.getOpt(pair[0]),
                  encodeURIComponent(pair[1])
                ].join("=");
              })
            );
            $2.xhr.open($2.getOpt("testMethod"), $h.getTarget("test", params));
            $2.xhr.timeout = $2.getOpt("xhrTimeout");
            $2.xhr.withCredentials = $2.getOpt("withCredentials");
            var customHeaders = $2.getOpt("headers");
            if (typeof customHeaders === "function") {
              customHeaders = customHeaders($2.fileObj, $2);
            }
            $h.each(customHeaders, function(k, v) {
              $2.xhr.setRequestHeader(k, v);
            });
            $2.xhr.send(null);
          };
          $2.preprocessFinished = function() {
            $2.preprocessState = 2;
            $2.send();
          };
          $2.send = function() {
            var preprocess = $2.getOpt("preprocess");
            if (typeof preprocess === "function") {
              switch ($2.preprocessState) {
                case 0:
                  $2.preprocessState = 1;
                  preprocess($2);
                  return;
                case 1:
                  return;
                case 2:
                  break;
              }
            }
            if ($2.getOpt("testChunks") && !$2.tested) {
              $2.test();
              return;
            }
            $2.xhr = new XMLHttpRequest();
            $2.xhr.upload.addEventListener("progress", function(e) {
              if (/* @__PURE__ */ new Date() - $2.lastProgressCallback > $2.getOpt("throttleProgressCallbacks") * 1e3) {
                $2.callback("progress");
                $2.lastProgressCallback = /* @__PURE__ */ new Date();
              }
              $2.loaded = e.loaded || 0;
            }, false);
            $2.loaded = 0;
            $2.pendingRetry = false;
            $2.callback("progress");
            var doneHandler = function(e) {
              var status = $2.status();
              if (status == "success" || status == "error") {
                $2.callback(status, $2.message());
                $2.resumableObj.uploadNextChunk();
              } else {
                $2.callback("retry", $2.message());
                $2.abort();
                $2.retries++;
                var retryInterval = $2.getOpt("chunkRetryInterval");
                if (retryInterval !== void 0) {
                  $2.pendingRetry = true;
                  setTimeout($2.send, retryInterval);
                } else {
                  $2.send();
                }
              }
            };
            $2.xhr.addEventListener("load", doneHandler, false);
            $2.xhr.addEventListener("error", doneHandler, false);
            $2.xhr.addEventListener("timeout", doneHandler, false);
            var query = [
              ["chunkNumberParameterName", $2.offset + 1],
              ["chunkSizeParameterName", $2.getOpt("chunkSize")],
              ["currentChunkSizeParameterName", $2.endByte - $2.startByte],
              ["totalSizeParameterName", $2.fileObjSize],
              ["typeParameterName", $2.fileObjType],
              ["identifierParameterName", $2.fileObj.uniqueIdentifier],
              ["fileNameParameterName", $2.fileObj.fileName],
              ["relativePathParameterName", $2.fileObj.relativePath],
              ["totalChunksParameterName", $2.fileObj.chunks.length]
            ].filter(function(pair) {
              return $2.getOpt(pair[0]);
            }).reduce(function(query2, pair) {
              query2[$2.getOpt(pair[0])] = pair[1];
              return query2;
            }, {});
            var customQuery = $2.getOpt("query");
            if (typeof customQuery == "function")
              customQuery = customQuery($2.fileObj, $2);
            $h.each(customQuery, function(k, v) {
              query[k] = v;
            });
            var func = $2.fileObj.file.slice ? "slice" : $2.fileObj.file.mozSlice ? "mozSlice" : $2.fileObj.file.webkitSlice ? "webkitSlice" : "slice";
            var bytes = $2.fileObj.file[func]($2.startByte, $2.endByte, $2.getOpt("setChunkTypeFromFile") ? $2.fileObj.file.type : "");
            var data = null;
            var params = [];
            var parameterNamespace = $2.getOpt("parameterNamespace");
            if ($2.getOpt("method") === "octet") {
              data = bytes;
              $h.each(query, function(k, v) {
                params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join("="));
              });
            } else {
              data = new FormData();
              $h.each(query, function(k, v) {
                data.append(parameterNamespace + k, v);
                params.push([encodeURIComponent(parameterNamespace + k), encodeURIComponent(v)].join("="));
              });
              if ($2.getOpt("chunkFormat") == "blob") {
                data.append(parameterNamespace + $2.getOpt("fileParameterName"), bytes, $2.fileObj.fileName);
              } else if ($2.getOpt("chunkFormat") == "base64") {
                var fr = new FileReader();
                fr.onload = function(e) {
                  data.append(parameterNamespace + $2.getOpt("fileParameterName"), fr.result);
                  $2.xhr.send(data);
                };
                fr.readAsDataURL(bytes);
              }
            }
            var target = $h.getTarget("upload", params);
            var method = $2.getOpt("uploadMethod");
            $2.xhr.open(method, target);
            if ($2.getOpt("method") === "octet") {
              $2.xhr.setRequestHeader("Content-Type", "application/octet-stream");
            }
            $2.xhr.timeout = $2.getOpt("xhrTimeout");
            $2.xhr.withCredentials = $2.getOpt("withCredentials");
            var customHeaders = $2.getOpt("headers");
            if (typeof customHeaders === "function") {
              customHeaders = customHeaders($2.fileObj, $2);
            }
            $h.each(customHeaders, function(k, v) {
              $2.xhr.setRequestHeader(k, v);
            });
            if ($2.getOpt("chunkFormat") == "blob") {
              $2.xhr.send(data);
            }
          };
          $2.abort = function() {
            if ($2.xhr)
              $2.xhr.abort();
            $2.xhr = null;
          };
          $2.status = function() {
            if ($2.pendingRetry) {
              return "uploading";
            } else if (!$2.xhr) {
              return "pending";
            } else if ($2.xhr.readyState < 4) {
              return "uploading";
            } else {
              if ($2.xhr.status == 200 || $2.xhr.status == 201) {
                return "success";
              } else if ($h.contains($2.getOpt("permanentErrors"), $2.xhr.status) || $2.retries >= $2.getOpt("maxChunkRetries")) {
                return "error";
              } else {
                $2.abort();
                return "pending";
              }
            }
          };
          $2.message = function() {
            return $2.xhr ? $2.xhr.responseText : "";
          };
          $2.progress = function(relative) {
            if (typeof relative === "undefined")
              relative = false;
            var factor = relative ? ($2.endByte - $2.startByte) / $2.fileObjSize : 1;
            if ($2.pendingRetry)
              return 0;
            if (!$2.xhr || !$2.xhr.status)
              factor *= 0.95;
            var s = $2.status();
            switch (s) {
              case "success":
              case "error":
                return 1 * factor;
              case "pending":
                return 0 * factor;
              default:
                return $2.loaded / ($2.endByte - $2.startByte) * factor;
            }
          };
          return this;
        }
        $.uploadNextChunk = function() {
          var found = false;
          if ($.getOpt("prioritizeFirstAndLastChunk")) {
            $h.each($.files, function(file) {
              if (file.chunks.length && file.chunks[0].status() == "pending" && file.chunks[0].preprocessState === 0) {
                file.chunks[0].send();
                found = true;
                return false;
              }
              if (file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status() == "pending" && file.chunks[file.chunks.length - 1].preprocessState === 0) {
                file.chunks[file.chunks.length - 1].send();
                found = true;
                return false;
              }
            });
            if (found)
              return true;
          }
          $h.each($.files, function(file) {
            if (file.isPaused() === false) {
              $h.each(file.chunks, function(chunk) {
                if (chunk.status() == "pending" && chunk.preprocessState === 0) {
                  chunk.send();
                  found = true;
                  return false;
                }
              });
            }
            if (found)
              return false;
          });
          if (found)
            return true;
          var outstanding = false;
          $h.each($.files, function(file) {
            if (!file.isComplete()) {
              outstanding = true;
              return false;
            }
          });
          if (!outstanding) {
            $.fire("complete");
          }
          return false;
        };
        $.assignBrowse = function(domNodes, isDirectory) {
          if (typeof domNodes.length == "undefined")
            domNodes = [domNodes];
          $h.each(domNodes, function(domNode) {
            var input;
            if (domNode.tagName === "INPUT" && domNode.type === "file") {
              input = domNode;
            } else {
              input = document.createElement("input");
              input.setAttribute("type", "file");
              input.style.display = "none";
              domNode.addEventListener("click", function() {
                input.style.opacity = 0;
                input.style.display = "block";
                input.focus();
                input.click();
                input.style.display = "none";
              }, false);
              domNode.appendChild(input);
            }
            var maxFiles = $.getOpt("maxFiles");
            if (typeof maxFiles === "undefined" || maxFiles != 1) {
              input.setAttribute("multiple", "multiple");
            } else {
              input.removeAttribute("multiple");
            }
            if (isDirectory) {
              input.setAttribute("webkitdirectory", "webkitdirectory");
            } else {
              input.removeAttribute("webkitdirectory");
            }
            var fileTypes = $.getOpt("fileType");
            if (typeof fileTypes !== "undefined" && fileTypes.length >= 1) {
              input.setAttribute("accept", fileTypes.map(function(e) {
                return "." + e;
              }).join(","));
            } else {
              input.removeAttribute("accept");
            }
            input.addEventListener("change", function(e) {
              appendFilesFromFileList(e.target.files, e);
              var clearInput = $.getOpt("clearInput");
              if (clearInput) {
                e.target.value = "";
              }
            }, false);
          });
        };
        $.assignDrop = function(domNodes) {
          if (typeof domNodes.length == "undefined")
            domNodes = [domNodes];
          $h.each(domNodes, function(domNode) {
            domNode.addEventListener("dragover", preventDefault, false);
            domNode.addEventListener("dragenter", preventDefault, false);
            domNode.addEventListener("drop", onDrop, false);
          });
        };
        $.unAssignDrop = function(domNodes) {
          if (typeof domNodes.length == "undefined")
            domNodes = [domNodes];
          $h.each(domNodes, function(domNode) {
            domNode.removeEventListener("dragover", preventDefault);
            domNode.removeEventListener("dragenter", preventDefault);
            domNode.removeEventListener("drop", onDrop);
          });
        };
        $.isUploading = function() {
          var uploading = false;
          $h.each($.files, function(file) {
            if (file.isUploading()) {
              uploading = true;
              return false;
            }
          });
          return uploading;
        };
        $.upload = function() {
          if ($.isUploading())
            return;
          $.fire("uploadStart");
          for (var num = 1; num <= $.getOpt("simultaneousUploads"); num++) {
            $.uploadNextChunk();
          }
        };
        $.pause = function() {
          $h.each($.files, function(file) {
            file.abort();
          });
          $.fire("pause");
        };
        $.cancel = function() {
          $.fire("beforeCancel");
          for (var i = $.files.length - 1; i >= 0; i--) {
            $.files[i].cancel();
          }
          $.fire("cancel");
        };
        $.progress = function() {
          var totalDone = 0;
          var totalSize = 0;
          $h.each($.files, function(file) {
            totalDone += file.progress() * file.size;
            totalSize += file.size;
          });
          return totalSize > 0 ? totalDone / totalSize : 0;
        };
        $.addFile = function(file, event) {
          appendFilesFromFileList([file], event);
        };
        $.addFiles = function(files, event) {
          appendFilesFromFileList(files, event);
        };
        $.removeFile = function(file) {
          for (var i = $.files.length - 1; i >= 0; i--) {
            if ($.files[i] === file) {
              $.files.splice(i, 1);
            }
          }
        };
        $.getFromUniqueIdentifier = function(uniqueIdentifier) {
          var ret = false;
          $h.each($.files, function(f) {
            if (f.uniqueIdentifier == uniqueIdentifier)
              ret = f;
          });
          return ret;
        };
        $.getSize = function() {
          var totalSize = 0;
          $h.each($.files, function(file) {
            totalSize += file.size;
          });
          return totalSize;
        };
        $.handleDropEvent = function(e) {
          onDrop(e);
        };
        $.handleChangeEvent = function(e) {
          appendFilesFromFileList(e.target.files, e);
          e.target.value = "";
        };
        $.updateQuery = function(query) {
          $.opts.query = query;
        };
        return this;
      };
      if (typeof module != "undefined") {
        module.exports = Resumable2;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return Resumable2;
        });
      } else {
        window.Resumable = Resumable2;
      }
    })();
  }
});

// node_modules/.pnpm/@whoj+utils-core@1.8.0/node_modules/@whoj/utils-core/dist/index.mjs
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var isExtglob$1 = function isExtglob(str) {
  if (typeof str !== "string" || str === "") {
    return false;
  }
  var match;
  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
    if (match[2])
      return true;
    str = str.slice(match.index + match[0].length);
  }
  return false;
};
var isExtglob2 = isExtglob$1;
var chars = { "{": "}", "(": ")", "[": "]" };
var strictCheck = function(str) {
  if (str[0] === "!") {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === "*") {
      return true;
    }
    if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
      return true;
    }
    if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf("]", index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }
    if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
      closeCurlyIndex = str.indexOf("}", index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }
    if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
      closeParenIndex = str.indexOf(")", index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf("\\", index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }
    if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf("|", index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
        closeParenIndex = str.indexOf(")", pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf("\\", pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }
    if (str[index] === "\\") {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }
      if (str[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var relaxedCheck = function(str) {
  if (str[0] === "!") {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }
    if (str[index] === "\\") {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];
      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }
      if (str[index] === "!") {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};
var isGlob = function isGlob2(str, options) {
  if (typeof str !== "string" || str === "") {
    return false;
  }
  if (isExtglob2(str)) {
    return true;
  }
  var check = strictCheck;
  if (options && options.strict === false) {
    check = relaxedCheck;
  }
  return check(str);
};
var isGlob$1 = getDefaultExportFromCjs(isGlob);
var assert = (condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
};
var toString = (val) => Object.prototype.toString.call(val);
var noop = () => {
};
var isDef = (val) => typeof val !== "undefined";
var isBoolean = (val) => typeof val === "boolean";
var isFunction = (val) => typeof val === "function";
var isNumber = (val) => typeof val === "number";
var isNumberish = (val) => typeof val === "number" || !isNaN(val);
var isString = (val) => typeof val === "string";
var isObject$1 = (val) => toString(val) === "[object Object]";
var isArray = (val) => Array.isArray(val);
var isWindow = (val) => typeof window !== "undefined" && toString(val) === "[object Window]";
var isBrowser = typeof window !== "undefined";
var hasConsole = typeof console !== "undefined";
var isGlobPattern = isGlob$1;
function notNullish(v) {
  return v != null;
}
function noNull(v) {
  return v !== null;
}
function notUndefined(v) {
  return v !== void 0;
}
function isTruthy(v) {
  return Boolean(v);
}
function objectMap(obj, fn) {
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish)
  );
}
function isKeyOf(obj, k) {
  return k in obj;
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function objectEntries(obj) {
  return Object.entries(obj);
}
function deepMerge(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (source === void 0) {
    return target;
  }
  if (isObjectMergable(target) && isObjectMergable(source)) {
    objectKeys(source).forEach((key) => {
      if (isObjectMergable(source[key])) {
        if (!target[key]) {
          target[key] = {};
        }
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    });
  }
  return deepMerge(target, ...sources);
}
function isObjectMergable(item) {
  return isObject$1(item) && !Array.isArray(item);
}
function objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0) {
        n[k] = obj[k];
      }
    }
    return n;
  }, {});
}
function clearUndefined(obj) {
  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
  return obj;
}
function hasOwnProperty(obj, key) {
  if (obj == null) {
    return false;
  }
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function fromPairs(pairs) {
  return pairs.reduce((obj, [key, val]) => ({
    ...obj,
    [key]: val
  }), {});
}
function toPairs(obj) {
  return objectEntries(obj);
}
function clamp(n, min, max) {
  return Math.min(max, Math.max(min, n));
}
function sum(...args) {
  return flattenArrayable(args).reduce((a, b) => a + b, 0);
}
function toArray(array) {
  array = array || [];
  if (Array.isArray(array)) {
    return array;
  }
  return [array];
}
function flattenArrayable(array) {
  return toArray(array).flat(1);
}
function mergeArrayable(...args) {
  return args.flatMap((i) => toArray(i));
}
function partition(array, ...filters) {
  const result = new Array(filters.length + 1).fill(null).map(() => []);
  array.forEach((e, idx, arr) => {
    let i = 0;
    for (const filter of filters) {
      if (filter(e, idx, arr)) {
        result[i].push(e);
        return;
      }
      i += 1;
    }
    result[i].push(e);
  });
  return result;
}
function uniq(array) {
  return Array.from(new Set(array));
}
function last(array) {
  return at(array, -1);
}
function remove(array, value) {
  if (!array) {
    return false;
  }
  const index = array.indexOf(value);
  if (index >= 0) {
    array.splice(index, 1);
    return true;
  }
  return false;
}
function at(array, index) {
  const len = array.length;
  if (!len) {
    return void 0;
  }
  if (index < 0) {
    index += len;
  }
  return array[index];
}
function range(...args) {
  let start, stop, step;
  if (args.length === 1) {
    start = 0;
    step = 1;
    [stop] = args;
  } else {
    [start, stop, step = 1] = args;
  }
  const arr = [];
  let current = start;
  while (current < stop) {
    arr.push(current);
    current += step || 1;
  }
  return arr;
}
function move(arr, from, to) {
  arr.splice(to, 0, arr.splice(from, 1)[0]);
  return arr;
}
function clampArrayRange(n, arr) {
  return clamp(n, 0, arr.length - 1);
}
function sample(arr, count) {
  return Array.from({ length: count }, (_) => arr[Math.round(Math.random() * (arr.length - 1))]);
}
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
function flattenDeepArray(array, key) {
  const fArray = [];
  const _myArray = toArray(array);
  if (!key) {
    return _myArray;
  }
  diveDeepArray(
    _myArray,
    "children",
    (a) => {
      fArray.push(a);
    }
  );
  return fArray;
}
function diveDeepArray(arr, key, callback) {
  arr.forEach((child) => {
    if (hasOwnProperty(child, key) && Array.isArray(child[key])) {
      diveDeepArray(child[key], key, callback);
    } else {
      callback(child, key);
    }
  });
}
var Emitter = class {
  constructor() {
    __publicField(this, "_t");
    try {
      this._t = new EventTarget();
    } catch (e) {
      this._t = document == null ? void 0 : document.createDocumentFragment();
    }
  }
  on(event, callback, ctx = {}) {
    callback._p = (e) => callback.apply(null, e._p);
    return this._t.addEventListener(event, callback._p, ctx);
  }
  off(event, callback) {
    return this._t.removeEventListener(event, callback._p);
  }
  emit(event, args) {
    const e = new Event(event);
    e._p = args;
    return this._t.dispatchEvent(e);
  }
  once(event, callback, ctx = {}) {
    return this.on(event, callback, { ...ctx, once: true });
  }
};
function batchInvoke(functions) {
  functions.forEach((fn) => fn && fn());
}
function invoke(fn) {
  return fn();
}
function tap(val, callback) {
  return callback(val);
}
var isServer = () => typeof window === "undefined";
var isClient = () => !isServer();
var getWindow = () => isServer() ? void 0 : window;
var getDocument = () => typeof document === "undefined" ? void 0 : document;
var fakeGlobal = {};
var _globalThis = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  return fakeGlobal;
}();
function getGlobal(prop) {
  return !prop ? _globalThis : _globalThis[prop];
}
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise) {
      _promise = fn();
    }
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev) {
      await _prev;
    }
  };
  return wrapper;
}
function sleep(ms, callback) {
  return new Promise(
    (resolve) => setTimeout(async () => {
      await (callback == null ? void 0 : callback());
      resolve();
    }, ms)
  );
}
function createPromiseLock() {
  const locks = [];
  return {
    async run(fn) {
      const p = fn();
      locks.push(p);
      try {
        return await p;
      } finally {
        remove(locks, p);
      }
    },
    async wait() {
      await Promise.allSettled(locks);
    },
    isWaiting() {
      return Boolean(locks.length);
    },
    clear() {
      locks.length = 0;
    }
  };
}
function createControlledPromise() {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}
function parallel(tasks, fn) {
  return Promise.all(tasks.map((task) => fn(task)));
}
function serial(tasks, fn) {
  return tasks.reduce(
    (promise, task) => promise.then((previous) => fn(task, previous)),
    Promise.resolve(null)
  );
}
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
function slash(str) {
  return str.replace(/\\/g, "/");
}
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
function ensurePrefix(prefix, str) {
  if (!str.startsWith(prefix)) {
    return prefix + str;
  }
  return str;
}
function ensureSuffix(suffix, str) {
  if (!str.endsWith(suffix)) {
    return str + suffix;
  }
  return str;
}
function template(str, ...args) {
  return str.replace(/{(\d+)}/g, (match, key) => {
    const index = Number(key);
    if (Number.isNaN(index)) {
      return match;
    }
    return args[index];
  });
}
function divideStr(str, separator, position = 1) {
  if (str.includes(separator)) {
    const arr = str.split(separator);
    return [
      arr.slice(0, position).join(separator),
      arr.slice(position).join(separator)
    ];
  }
  return [str, ""];
}
var Timer = class {
  /**
   * @param cb - Callback for setTimeout
   * @param interval - delay (in millisecond)
   *
   * @beta
   */
  constructor(cb, interval) {
    __publicField(this, "timerId");
    __publicField(this, "startedAt");
    __publicField(this, "interval");
    /**
     * @readonly
     */
    __publicField(this, "callback");
    this.startedAt = Date.now();
    this.callback = cb;
    this.interval = interval;
    this.timerId = setTimeout(cb, interval);
  }
  /**
   * It stops the timer, then subtracts the time that has passed since the timer was started from the interval
   */
  pause() {
    this.stop();
    this.interval -= Date.now() - this.startedAt;
  }
  /**
   * It resumes the timer by setting the startedAt property to the current time, and then setting the timerId property to
   * the result of calling setTimeout with the callback and interval properties
   */
  resume() {
    this.stop();
    this.startedAt = Date.now();
    this.timerId = setTimeout(this.callback, this.interval);
  }
  stop() {
    clearTimeout(this.timerId);
  }
};
var timestamp = () => +Date.now();
function stoppableTimeOut(cb, interval) {
  return new Timer(cb, interval);
}
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return void 0;
  }
  return char.toUpperCase() === char;
}
function splitByCase(string_, separators) {
  const splitters = separators ?? STR_SPLITTERS;
  const parts = [];
  if (!string_ || typeof string_ !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of string_) {
    const isSplitter = splitters.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff[buff.length - 1];
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function upperFirst(string_) {
  return !string_ ? "" : string_[0].toUpperCase() + string_.slice(1);
}
function lowerFirst(string_) {
  return !string_ ? "" : string_[0].toLowerCase() + string_.slice(1);
}
function pascalCase(string_) {
  return !string_ ? "" : (Array.isArray(string_) ? string_ : splitByCase(string_)).map((p) => upperFirst(p)).join("");
}
function camelCase(string_) {
  return lowerFirst(pascalCase(string_));
}
function kebabCase(string_, joiner) {
  return !string_ ? "" : (Array.isArray(string_) ? string_ : splitByCase(string_)).map((p) => p.toLowerCase()).join(joiner ?? "-");
}
function snakeCase(string_) {
  return kebabCase(string_, "_");
}
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}
var isObject = (value) => {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
};
var disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
var digits = new Set("0123456789");
function getPathSegments(path) {
  const parts = [];
  let currentSegment = "";
  let currentPart = "start";
  let isIgnoring = false;
  for (const character of path) {
    switch (character) {
      case "\\": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (isIgnoring) {
          currentSegment += character;
        }
        currentPart = "property";
        isIgnoring = !isIgnoring;
        break;
      }
      case ".": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        currentSegment = "";
        currentPart = "property";
        break;
      }
      case "[": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = "";
        }
        currentPart = "index";
        break;
      }
      case "]": {
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10));
          currentSegment = "";
          currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
      }
      default: {
        if (currentPart === "index" && !digits.has(character)) {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (currentPart === "start") {
          currentPart = "property";
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += "\\";
        }
        currentSegment += character;
      }
    }
  }
  if (isIgnoring) {
    currentSegment += "\\";
  }
  switch (currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment)) {
        return [];
      }
      parts.push(currentSegment);
      break;
    }
    case "index": {
      throw new Error("Index was not closed");
    }
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex(object, key) {
  if (typeof key !== "number" && Array.isArray(object)) {
    const index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object[index] === object[key];
  }
  return false;
}
function assertNotStringIndex(object, key) {
  if (isStringIndex(object, key)) {
    throw new Error("Cannot use string index");
  }
}
function getProperty(object, path, value) {
  if (!isObject(object) || typeof path !== "string") {
    return value === void 0 ? object : value;
  }
  const pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return value;
  }
  for (let index = 0; index < pathArray.length; index++) {
    const key = pathArray[index];
    if (isStringIndex(object, key)) {
      object = index === pathArray.length - 1 ? void 0 : null;
    } else {
      object = object[key];
    }
    if (object === void 0 || object === null) {
      if (index !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object === void 0 ? value : object;
}
function setProperty(object, path, value) {
  if (!isObject(object) || typeof path !== "string") {
    return object;
  }
  const root = object;
  const pathArray = getPathSegments(path);
  for (let index = 0; index < pathArray.length; index++) {
    const key = pathArray[index];
    assertNotStringIndex(object, key);
    if (index === pathArray.length - 1) {
      object[key] = value;
    } else if (!isObject(object[key])) {
      object[key] = typeof pathArray[index + 1] === "number" ? [] : {};
    }
    object = object[key];
  }
  return root;
}
function deleteProperty(object, path) {
  if (!isObject(object) || typeof path !== "string") {
    return false;
  }
  const pathArray = getPathSegments(path);
  for (let index = 0; index < pathArray.length; index++) {
    const key = pathArray[index];
    assertNotStringIndex(object, key);
    if (index === pathArray.length - 1) {
      delete object[key];
      return true;
    }
    object = object[key];
    if (!isObject(object)) {
      return false;
    }
  }
}
function hasProperty(object, path) {
  if (!isObject(object) || typeof path !== "string") {
    return false;
  }
  const pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return false;
  }
  for (const key of pathArray) {
    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {
      return false;
    }
    object = object[key];
  }
  return true;
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function lowerCase(str) {
  return str.toLowerCase();
}
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign({ delimiter: "." }, options));
}
function pathCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "/" }, options));
}
function paramCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign({ delimiter: "-" }, options));
}
function changeCase(str, to) {
  switch (to) {
    case "camel":
      return camelCase(str);
    case "kebab":
      return kebabCase(str);
    case "pascal":
      return pascalCase(str);
    case "snake":
      return snakeCase(str);
    default:
      return str;
  }
}

// node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js
function isArray2(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function isString2(value) {
  return typeof value === "string";
}
function isNumber2(value) {
  return typeof value === "number";
}
function isBoolean2(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject2(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject2(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString2(key) || isArray2(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray2(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray2(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString2(value) || isNumber2(value) || isBoolean2(value))) {
        list.push(toString2(value));
      } else if (isArray2(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString2(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString2(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString2(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray2(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString2(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray2(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString2(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray2(query) && isObject2(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString2(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray2(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString2(query) ? isString2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber2(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray2(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/fusejs/index.mjs
import { ref, watch, computed } from "vue-demi";
var FuseJS = class {
  /**
   * We create a new Fuse instance with the list of items and options, and then we create a computed property that returns
   * the results of the search
   * @param list - This is the list of items that you want to search. It can be an array of items, or a reactive object
   * that contains an array of items.
   * @param options - FuseOptions<DataT>
   */
  constructor(list, options) {
    /**
     * @type Ref
     */
    __publicField(this, "fuse");
    /**
     * @type Ref
     */
    __publicField(this, "resultsRaw");
    /**
     * @type ComputedRef
     */
    __publicField(this, "results");
    /**
     * @type Ref
     */
    __publicField(this, "search");
    /**
     * @type ComputedRef
     */
    __publicField(this, "noResults");
    this.search = ref("");
    let locArr = [];
    if (Array.isArray(list)) {
      locArr = list;
    } else if (list) {
      locArr = list.value ?? [];
      watch(list, () => {
        this.loadItems(list.value ?? []);
      });
    }
    this.fuse = ref(new Fuse(locArr, options));
    this.resultsRaw = ref([]);
    this.noResults = computed(() => {
      return this.results.value.length === 0 && this.search.value.length > 0;
    });
    this.results = computed(() => this.resultsRaw.value.map((r) => r.item));
    watch(this.search, this.runSearch);
  }
  /**
   * @param items
   * @param options
   */
  /**
   * It takes an array of items and an optional FuseOptions object, and then it creates a new Fuse instance with those
   * items and options, and then it runs the search with the current search value
   * @param items - DataT[] - The items to search through.
   * @param options - FuseOptions<DataT>
   */
  loadItems(items, options) {
    this.fuse = ref(new Fuse(items, options));
    this.runSearch(this.search.value);
  }
  /**
   * If there is no search string, clear the results. Otherwise, search the fuse
   * @param {string} [search] - The search string to use.
   * @returns The results of the search.
   */
  runSearch(search2) {
    if (!this.fuse) {
      return;
    }
    if (!search2) {
      this.resultsRaw.value = [];
      return;
    }
    this.resultsRaw.value = this.fuse.value.search(search2);
  }
};
function useFuseJs(list, options) {
  return new FuseJS(list, options);
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/ripple/index.mjs
import { isVue3 } from "vue-demi";
function setProps(modifiers, props) {
  modifiers.forEach((item) => {
    if (!isNumber(item)) {
      props.event = item;
    } else {
      props.transition = item;
    }
  });
}
function rippleHandler(el, modifiers, options) {
  const props = {
    event: "mousedown",
    transition: 600
  };
  setProps(objectKeys(modifiers), props);
  el.addEventListener(props.event, (event) => {
    rippleEl(event, el);
  });
  const bg = (options == null ? void 0 : options.color) || "rgba(0, 0, 0, 0.35)";
  const zIndex = (options == null ? void 0 : options.zIndex) || "9999";
  const rippleEl = function(event, el2) {
    const target = el2;
    const targetBorder = parseInt(getComputedStyle(target).borderWidth.replace("px", ""));
    const clientX = event.clientX || event.touches[0].clientX;
    const clientY = event.clientY || event.touches[0].clientY;
    const rect = target.getBoundingClientRect();
    const left = rect.left;
    const top = rect.top;
    const width = target.offsetWidth;
    const height = target.offsetHeight;
    const dx = clientX - left;
    const dy = clientY - top;
    const maxX = Math.max(dx, width - dx);
    const maxY = Math.max(dy, height - dy);
    const style = window.getComputedStyle(target);
    const radius = Math.sqrt(maxX * maxX + maxY * maxY);
    const border = targetBorder > 0 ? targetBorder : 0;
    const ripple = document.createElement("div");
    const rippleContainer = document.createElement("div");
    rippleContainer.className = "ripple-container";
    ripple.className = "ripple";
    ripple.style.marginTop = "0px";
    ripple.style.marginLeft = "0px";
    ripple.style.width = "1px";
    ripple.style.height = "1px";
    ripple.style.transition = `all ${props.transition}ms cubic-bezier(0.4, 0, 0.2, 1)`;
    ripple.style.borderRadius = "50%";
    ripple.style.pointerEvents = "none";
    ripple.style.position = "relative";
    ripple.style.zIndex = zIndex;
    ripple.style.backgroundColor = bg;
    rippleContainer.style.position = "absolute";
    rippleContainer.style.left = `${0 - border}px`;
    rippleContainer.style.top = `${0 - border}px`;
    rippleContainer.style.height = "0";
    rippleContainer.style.width = "0";
    rippleContainer.style.pointerEvents = "none";
    rippleContainer.style.overflow = "hidden";
    const storedTargetPosition = target.style.position.length > 0 ? target.style.position : getComputedStyle(target).position;
    if (storedTargetPosition !== "relative") {
      target.style.position = "relative";
    }
    rippleContainer.appendChild(ripple);
    target.appendChild(rippleContainer);
    ripple.style.marginLeft = `${dx}px`;
    ripple.style.marginTop = `${dy}px`;
    rippleContainer.style.width = `${width}px`;
    rippleContainer.style.height = `${height}px`;
    rippleContainer.style.borderTopLeftRadius = style.borderTopLeftRadius;
    rippleContainer.style.borderTopRightRadius = style.borderTopRightRadius;
    rippleContainer.style.borderBottomLeftRadius = style.borderBottomLeftRadius;
    rippleContainer.style.borderBottomRightRadius = style.borderBottomRightRadius;
    rippleContainer.style.direction = "ltr";
    setTimeout(() => {
      ripple.style.width = `${radius * 2}px`;
      ripple.style.height = `${radius * 2}px`;
      ripple.style.marginLeft = `${dx - radius}px`;
      ripple.style.marginTop = `${dy - radius}px`;
    }, 0);
    function clearRipple() {
      setTimeout(() => {
        ripple.style.backgroundColor = "rgba(0, 0, 0, 0)";
      }, 250);
      setTimeout(() => {
        var _a;
        (_a = rippleContainer.parentNode) == null ? void 0 : _a.removeChild(rippleContainer);
      }, 850);
      el2.removeEventListener("mouseup", clearRipple, false);
      el2.removeEventListener("mouseleave", clearRipple, false);
      el2.removeEventListener("dragstart", clearRipple, false);
      setTimeout(() => {
        let clearPosition = true;
        for (const child of target.childNodes) {
          if (child.className === "ripple-container") {
            clearPosition = false;
          }
        }
        if (clearPosition) {
          if (storedTargetPosition !== "static") {
            target.style.position = storedTargetPosition;
          } else {
            target.style.position = "";
          }
        }
      }, props.transition + 250);
    }
    if (event.type === "mousedown") {
      el2.addEventListener("mouseup", clearRipple, false);
      el2.addEventListener("mouseleave", clearRipple, false);
      el2.addEventListener("dragstart", clearRipple, false);
    } else {
      clearRipple();
    }
  };
}
function makeRippleDir(options = {}) {
  return {
    [`${isVue3 ? "beforeMount" : "bind"}`]: (el, binding) => rippleHandler(
      el,
      binding.modifiers,
      { ...options, color: binding.value }
    )
  };
}
var vRipple = makeRippleDir();
function useRipple(el, event, options) {
  const element = el instanceof HTMLElement ? el : el.value;
  rippleHandler(element, event ? { [event]: true } : { mousedown: true }, options);
}
var Ripple = {
  install(app, options) {
    app.directive("ripple", makeRippleDir(options));
  }
};

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/img-fallback/index.mjs
import { isVue3 as isVue32 } from "vue-demi";
var loadingImg = "data:image/gif;base64,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";
function makeImgFallbackDir(options = {}) {
  return {
    [`${isVue32 ? "beforeMount" : "bind"}`]: (el, binding) => {
      const { value } = binding;
      const defaultLoading = (options == null ? void 0 : options.loading) || loadingImg;
      const defaultError = (options == null ? void 0 : options.error) || (options == null ? void 0 : options.loading) || loadingImg;
      const img = new Image();
      let loading = defaultLoading;
      let error = defaultError;
      const original = el.src;
      if (!value) {
        console.warn(
          `Vue Img Fallback Warning: Directive value is ${typeof value}. Now using default values.`
        );
      }
      if (isString(value)) {
        loading = error = value;
      } else if (isObject$1(value)) {
        loading = value.loading || defaultLoading;
        error = value.error || defaultError;
      }
      img.src = original;
      el.src = loading;
      img.onload = () => {
        el.src = original;
      };
      img.onerror = () => {
        el.src = error;
      };
    }
  };
}
var vImgFallback = makeImgFallbackDir();
var ImgFallback = {
  install(app, options) {
    app.directive("img-fallback", makeImgFallbackDir(options));
  }
};

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/refOf.mjs
import { computed as computed2, ref as ref2 } from "vue-demi";
function refOf(r) {
  return typeof r === "function" ? computed2(r) : ref2(r);
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/unrefOf.mjs
import { unref } from "vue-demi";
function unrefOf(r) {
  return typeof r === "function" ? r() : unref(r);
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/unrefOfEl.mjs
function unrefElement(elRef) {
  const plain = unrefOf(elRef);
  return (plain == null ? void 0 : plain.$el) ?? plain;
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/useLinkTag.mjs
import { ref as ref3, watch as watch3 } from "vue-demi";

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/listenEvent.mjs
import { watch as watch2 } from "vue-demi";

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/tryOnScopeDispose.mjs
import { getCurrentScope, onScopeDispose } from "vue-demi";
function tryOnScopeDispose(func) {
  if (getCurrentScope()) {
    onScopeDispose(func);
    return true;
  }
  return false;
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/listenEvent.mjs
var defaultWindow = isClient() ? window : void 0;
var defaultDocument = isClient() ? window.document : void 0;
function listenEvent(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target) {
    return noop;
  }
  if (!Array.isArray(events)) {
    events = [events];
  }
  if (!Array.isArray(listeners)) {
    listeners = [listeners];
  }
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register2 = (el, event, listener) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const stopWatch = watch2(
    () => unrefElement(target),
    (el) => {
      cleanup();
      if (!el) {
        return;
      }
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register2(el, event, listener));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/tryOnMounted.mjs
import { getCurrentInstance, onMounted, nextTick } from "vue-demi";
function tryOnMounted(func, sync = true) {
  if (getCurrentInstance()) {
    onMounted(() => func());
  } else if (sync) {
    func();
  } else {
    nextTick(() => func());
  }
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/tryOnUnmounted.mjs
import { getCurrentInstance as getCurrentInstance2, onUnmounted } from "vue-demi";
function tryOnUnmounted(func) {
  if (getCurrentInstance2()) {
    onUnmounted(func);
  }
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/useLinkTag.mjs
var _id = 0;
function useLinkTag(href, onLoaded = noop, options = {}) {
  const {
    as,
    media,
    crossOrigin,
    referrerPolicy,
    blocking,
    immediate = true,
    manual = false,
    attrs = {},
    type = "text/css",
    rel = "stylesheet",
    id = `use_link_tag_${++_id}`,
    document: document2 = getDocument()
  } = options;
  const linkTag = ref3();
  const loaded = ref3();
  let _promise = null;
  const _evtListeners = {};
  const findLinkEl = () => document2.querySelector(`link[id="${id}"]`);
  const loadLink = (waitForLoad) => new Promise((resolve, reject) => {
    const resolveWithElement = (el2) => {
      linkTag.value = el2;
      resolve(el2);
      return el2;
    };
    if (!document2) {
      resolve(false);
      return;
    }
    let shouldAppend = false;
    let el = findLinkEl();
    if (!el) {
      el = document2.createElement("link");
      el.id = id;
      el.rel = rel;
      el.type = type;
      el.href = unrefOf(href);
      if (as) {
        el.as = as;
      }
      if (media) {
        el.media = media;
      }
      if (crossOrigin) {
        el.crossOrigin = crossOrigin;
      }
      if (referrerPolicy) {
        el.referrerPolicy = referrerPolicy;
      }
      if (blocking) {
        attrs.blocking = blocking;
      }
      objectEntries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));
      shouldAppend = true;
    } else if (el.hasAttribute("data-loaded")) {
      resolveWithElement(el);
    }
    _evtListeners.error = listenEvent(el, "error", (event) => reject(event));
    _evtListeners.abort = listenEvent(el, "abort", (event) => reject(event));
    _evtListeners.load = listenEvent(el, "load", () => {
      el.setAttribute("data-loaded", "true");
      loaded.value = true;
      onLoaded(el);
      resolveWithElement(el);
    });
    if (shouldAppend) {
      el = document2.head.appendChild(el);
    }
    if (!waitForLoad) {
      resolveWithElement(el);
    }
  });
  const load = (waitForLoad = true) => {
    if (!_promise) {
      _promise = loadLink(waitForLoad);
    }
    return _promise;
  };
  const unload = () => {
    if (!document2) {
      return;
    }
    _promise = null;
    if (linkTag.value) {
      linkTag.value = void 0;
    }
    const el = findLinkEl();
    if (el) {
      objectEntries(_evtListeners).forEach(([name, unregister]) => {
        unregister();
      });
      document2.head.removeChild(el);
    }
    loaded.value = void 0;
  };
  const update = () => {
    const el = findLinkEl();
    if (el) {
      el.href = unrefOf(href);
    }
  };
  if (immediate && !manual) {
    tryOnMounted(load);
  }
  if (!manual) {
    tryOnUnmounted(unload);
  }
  watch3(
    () => unrefOf(href),
    update,
    { immediate: true, flush: "post" }
  );
  return { linkTag, loaded, load, unload };
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/useStyleTag.mjs
import { ref as ref4, readonly, watch as watch4 } from "vue-demi";
var _id2 = 0;
function useStyleTag(css, options = {}) {
  const isLoaded = ref4(false);
  const {
    document: document2 = defaultDocument,
    immediate = true,
    manual = false,
    id = `whoj.utils-vue_style_tag_${++_id2}`
  } = options;
  const cssRef = ref4(css);
  let stop = () => {
  };
  const load = () => {
    if (!document2) {
      return;
    }
    const el = document2.getElementById(id) || document2.createElement("style");
    if (!el.isConnected) {
      el.type = "text/css";
      el.id = id;
      if (options.media) {
        el.media = options.media;
      }
      document2.head.appendChild(el);
    }
    if (isLoaded.value) {
      return;
    }
    stop = watch4(
      cssRef,
      (value) => {
        el.textContent = value;
      },
      { immediate: true }
    );
    isLoaded.value = true;
  };
  const unload = () => {
    if (!document2 || !isLoaded.value) {
      return;
    }
    stop();
    document2.head.removeChild(document2.getElementById(id));
    isLoaded.value = false;
  };
  if (immediate && !manual) {
    tryOnMounted(load);
  }
  if (!manual) {
    tryOnScopeDispose(unload);
  }
  return {
    id,
    css: cssRef,
    unload,
    load,
    isLoaded: readonly(isLoaded)
  };
}

// node_modules/.pnpm/@whoj+utils-vue@1.8.0_vue@3.3.8/node_modules/@whoj/utils-vue/dist/composables/useResumableUploader.mjs
var import_resumablejs = __toESM(require_resumable(), 1);
import { ref as ref5 } from "vue-demi";
function useResumableUploader(options, target) {
  const files = ref5([]);
  const uploader = ref5();
  const findFile = (file) => {
    return files.value.find((item) => item.file.uniqueIdentifier === file.uniqueIdentifier && item.status !== "canceled");
  };
  const cancelFile = (file) => {
    const _file = findFile(file);
    if (_file) {
      _file.status = "canceled";
      file.cancel();
    }
  };
  const createResumable = () => {
    const _uploader = new import_resumablejs.default({
      maxChunkRetries: 1,
      testChunks: false,
      ...options
    });
    if (!_uploader.support) {
      throw new Error("Your browser doesn't support chunked uploads. Get a better browser.");
    }
    if (isFunction(target)) {
      uploader.value = target(_uploader);
    } else {
      const _browseEl = unrefElement(target.browse);
      if (_browseEl) {
        _uploader.assignBrowse(_browseEl, false);
      }
      if (isDef(target.drop)) {
        const _dropEl = unrefElement(target.drop);
        if (_dropEl) {
          _uploader.assignDrop(_dropEl);
        }
      }
      uploader.value = _uploader;
    }
    uploader.value.on("fileAdded", (file) => {
      file.hasUploaded = false;
      files.value.push({
        file,
        status: "uploading",
        progress: 0
      });
      uploader.value.upload();
    });
    uploader.value.on("fileSuccess", (file) => {
      findFile(file).status = "success";
    });
    uploader.value.on("fileError", (file) => {
      findFile(file).status = "error";
    });
    uploader.value.on("fileRetry", (file) => {
      findFile(file).status = "retrying";
    });
    uploader.value.on("fileProgress", (file) => {
      const localFile = findFile(file);
      const progress = file.progress(false);
      if (progress > localFile.progress) {
        localFile.progress = progress;
      }
    });
  };
  tryOnMounted(() => {
    createResumable();
  });
  return {
    files,
    uploader,
    findFile,
    cancelFile
  };
}
export {
  Emitter,
  FuseJS,
  ImgFallback,
  Ripple,
  assert,
  at,
  batchInvoke,
  camelCase,
  capitalize,
  changeCase,
  clamp,
  clampArrayRange,
  clearUndefined,
  createControlledPromise,
  createPromiseLock,
  createSingletonPromise,
  debounce,
  deepMerge,
  deleteProperty as deleteObjProp,
  deleteProperty,
  divideStr,
  dotCase,
  ensurePrefix,
  ensureSuffix,
  flattenArrayable,
  flattenDeepArray,
  fromPairs,
  getDocument,
  getGlobal,
  getProperty as getObjProp,
  getProperty,
  getWindow,
  hasConsole,
  hasProperty as hasObjProp,
  hasOwnProperty,
  hasProperty,
  invoke,
  isArray,
  isBoolean,
  isBrowser,
  isClient,
  isDef,
  isFunction,
  isGlobPattern,
  isKeyOf,
  isNumber,
  isNumberish,
  isObject$1 as isObject,
  isServer,
  isString,
  isTruthy,
  isWindow,
  kebabCase,
  last,
  listenEvent,
  mergeArrayable,
  move,
  noNull,
  noop,
  notNullish,
  notUndefined,
  objectEntries,
  objectKeys,
  objectMap,
  objectPick,
  parallel,
  paramCase,
  partition,
  pascalCase,
  pathCase,
  range,
  refOf,
  remove,
  sample,
  scrollToElement,
  serial,
  setProperty as setObjProp,
  setProperty,
  shuffle,
  slash,
  sleep,
  snakeCase,
  stoppableTimeOut,
  sum,
  tap,
  template,
  throttle,
  timestamp,
  toArray,
  toPairs,
  toString,
  tryOnMounted,
  tryOnScopeDispose,
  tryOnUnmounted,
  uniq,
  unrefElement,
  unrefOf,
  useFuseJs,
  useLinkTag,
  useResumableUploader,
  useRipple,
  useStyleTag,
  vImgFallback,
  vRipple
};
/*! Bundled license information:

@whoj/utils-core/dist/index.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-core@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

@whoj/utils-vue/dist/fusejs/index.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/ripple/index.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/img-fallback/index.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/refOf.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/unrefOf.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/unrefOfEl.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/tryOnScopeDispose.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/listenEvent.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/tryOnMounted.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/tryOnUnmounted.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/useLinkTag.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/useStyleTag.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/composables/useResumableUploader.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils-vue/dist/index.mjs:
  (**
   * @license MIT
   * @module @whoj/utils-vue@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)

@whoj/utils/dist/index.mjs:
  (**
   * @license MIT
   * @module @whoj/utils@1.8.0
   * @copyright (c) 2023 Jonson B.
   *)
*/
//# sourceMappingURL=@whoj_utils.js.map
